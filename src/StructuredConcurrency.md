## Введение

[`async`/`await`](AsyncAwait.md) — это механизм для написания понятного и производительного асинхронного кода.
Асинхронные функции (обозначенные `async`) могут оставить поток, на котором они выполняются, в любой заданной точке приостановки (обозначенной `await`), что необходимо для построения `highly-concurrent` систем.

Proposal по `async`/`await` не знакомит с понятием `concurrency` *как таковым*: игнорируя suspension points в `async` функции, выполнение будет таким же, как в синхронной.
Данный proposal вводит поддержку для [structured concurrency](https://en.wikipedia.org/wiki/Structured_concurrency) в Swift, включая concurrent выполнение асинхронного кода с более удобной, предсказуемой моделью и эффективной реализацией.

## Мотивация

На простом примере, приготовим ужин, асинхронно:

```swift
func chopVegetables() async throws -> [Vegetable] { ... }
func marinateMeat() async -> Meat { ... }
func preheatOven(temperature: Double) async throws -> Oven { ... }

// ...

func makeDinner() async throws -> Meal {
  let veggies = try await chopVegetables()
  let meat = await marinateMeat()
  let oven = try await preheatOven(temperature: 350)

  let dish = Dish(ingredients: [veggies, meat])
  return try await oven.cook(dish, duration: .hours(3))
}
```

Каждый шаг в приготовлении ужина — асинхронная операция, поэтому существует несколько suspention point.
В ожидании нарезки овощей, `makeDinner` не будет блокировать поток. Функция приостановится, пока овощи не готовы, а затем возобновится.
Возможно, множество готовящихся ужинов на разных стадиях и большинство из них будут приостановлены до завершения текущего шага.

Несмотря на `async` вызовы, приготовление остается последовательным. Сначала ждем нарезки овощей, затем мариновки мяса с овощами, далее разогреть духовку и только сейчас приступить к приготовлению.
К тому времени, посетители будут голодны и недовольны такой скоростью приготовления.

Для ускорения процесса будет делать некоторые действия одновременно. Овощи можно нарезать во время мариновки мяса и в это же время разогреем духовку.
Иногда между задачами существует зависимость: как только овощи и мясо будут готовы, мы можем соединить их в блюдо, но не можем поставить это блюдо в духовку, пока духовка не нагрелась.
Все эти задачи являются одной большой задачей по приготовлению ужина. При выполнении всех задач, ужин будет подан.

Данный proposal представляет инструменты для разделения задач на сопрограммы (более мелкие задачи), выполняя задачи конкурентно, что позволит задачам ждать завершения друг друга и эффективно управлять общим ходом выполнения задачи.

## Structured concurrency

Любая concurrency система должна предоставлять базовый набор инструментов. Должен быть способ создания нового потока, который будет `concurrency` выполняться с уже существующими.
Также, должен быть способ заставить поток ждать до сигнала другого потока о продолжении работы. Благодаря таким мощным инструментам, можно написать сложные системы.
В свою очередь, такие инструменты примитивны: дают мало возможностей и ограниченную поддержку.

Представим функцию, которая выполняет тяжелую работу на `CPU`. Оптимизировав функцию, мы разделили работу на два ядра.
Теперь функция создает новый поток, выполняет **1/2** работы в каждом, а затем заставляет исходный поток ждать завершения нового потока.
Существует взаимосвязь между работой, выполняемой этими двумя потоками, но система об этом не знает. Это значительно усложняет решение системных проблем.

Существует операция с высоким приоритетом, которая требует от функции ускориться и завершить работу.
Операция может знать, что нужно повысить приоритет первого потока, но на деле нужно повысить на обоих потоках.
В лучшем случае она не будет повышать приоритет второго потока, пока первый поток не начнет его ждать.
Данную задачу легко решить в текущей, узкой ситуации, позволив функции создать второй поток, но это не является универсальным решением.

`Structured concurrency` решает эту проблему, предлагая программистам организовать использование конкурентности в виде высокоуровневых и их дочерних задач.
Такие `task` являются основным элементом конкурентности, чем более низкоуровневые потоки.
`Structured concurrency` позволяет информации естественным образом перемещаться вверх/вниз по иерархии задач, что в противном случае потребовало бы хорошей поддержки каждого уровня абстракции и при каждом переходе между потоками.
В свою очередь, позволяет относительно легко решать многие проблемы высокого уровня.

Например:

1. Часто необходимо ограничить затрачиваемое время на выполнение задачи. Некоторые API поддерживают установку timeout, но требуется поразмыслить, как правильно передать timeout через каждый уровень абстракции.
Разработчики хотят передавать тайм-ауты в виде относительной длительности (например, 20 мс), но правильное представление для библиотек - это абсолютный срок (например, now() + 20 мс).
При `structured concurrency`, дедлайн можно установить для task и передать через произвольные уровни API, включая дочерние таски.

2. Возможность отменить активную задачу. Асинхронные интерфейсы, который поддерживают отмену задачи, обычно реализуют это с помощью возврата токена, который вызывает некую функцию `cancel()`.
Часто такой отмены нет, потому что это усложняет проектирование дизайна API и добавляет инженерные проблемы для программы.
Такая возможность есть в `structured concurrency`, в том числе и для дочерних задач. API поддерживает обработку на такое событие.

3. Часто графические интерфейсы полагаются на приоритет задачи для своевременного обновления и реагирование на события.
В `structured concurrency` дочерние задачи наследуют приоритет от родительской.
> ⚠️ Более того, в ситуации, когда задача с более высоким приоритетом ожидает завершения задачи с более низким приоритетом, приоритет может быть повышен.

4. Многие системы хотят хранить свою собственную контекстную информацию для операции без необходимости передавать ее через все уровни абстракции, например, сервер, который записывает информацию о текущем соединении.
`Structured concurrency`позволяет передавать эту информацию вниз через асинхронные операции как своего рода "локальное хранилище задач", которое может быть подхвачено дочерними задачами.

5. Системы, полагающиеся на очереди, подвержены переполнению.
Ситуация, когда очередь принимает больше, чем может. Обычным решение служит «выдавливание»(обратное давление). 
Акторным системам часто удается избежать этого, поскольку на уровне планировщика трудно отказаться от добавления задачи в очередь актора, поскольку это может окончательно дестабилизировать систему за счет утечки ресурсов или иного препятствования завершению операций.
`Structured concurrency` предлагает ограниченное, кооперативное решение, позволяя системе взаимодействовать c иерархией задач, позволяя родительским задачам остановить или замедлить создание предположительно новых задач.

Данное введение не предлагает решение для всех проблем выше, но исследование показывают перспективы.

## Task (задачи)

`Task` является основной единицей конкурентности в системе (concurrency in the system). Каждая `async` функция выполняется в `task`.
Другими словами, `task` — асинхронная функция, тогда как `thread` — синхронная функция:

- Все асинхронный функции работают как часть некоторой `task`.
- `Task` выполняет одну функцию за 1 раз; в одной `task` нет concurrency.
- Когда функция делает `async` вызов, вызванная функция выполняется как часть некоторой `task` (и ожидается возвращение).
- Когда функция возвращается из `async` вызова, функция продолжает выполнять `task`.

> ⚠️ Синхронные функции не обязательно выполняются как часть задачи.

`Task` может быть в одном из трех состояний:

1. **running**. Запущенная задача в данный момент выполняется в потоке.
Будет выполняться до тех пор, пока не вернется из своей начальной функции (и не станет завершенной), либо не достигнет момента/точки приостановки (и не станет приостановленной).
В точке приостановки она может сразу стать планируемой, если для ее выполнения нужно просто сменить исполнителя.

2. **suspended**. У приостановленной задачи еще осталась работа, но в данный момент она не выполняется.
Она может быть запланирована, то есть готова к выполнению и просто ждет, когда система даст команду потоку начать ее выполнение,
или она может ожидать какого-то внешнего события, прежде чем она станет планируемой.

3. **completed**. Завершенная задача, которая никогда не перейдет в другое состояние.
Система может ждать завершения `task` различными способами, но прежде всего с помощь `await`.

Говоря о выполнении задач, то `async` функции выполняются сложнее, чем синхронные.
`Async` функция выполняется как часть `task`. Если `task` выполняется, то она и ее функция тоже выполняются в потоке.

Когда `async` функция вызывает другую `async` функцию, мы говорим, что вызываемая функция `suspended`, но это не означает, что приостановлена задача целиком.
С точки зрения функции, она приостановлена, ожидая возврата вызова. С точки зрения задачи, она могла продолжать выполняться в вызывающей функции, или она могла быть приостановлена, чтобы, скажем, перейти в другой контекст выполнения.

Задачи служат 3-ем высоко уровневым целям:

1. Содержат `scheduling` информацию — task priority
2. Являются обработчиком через который операции могут быть отменены, queried or manipulated.
3. Могут содержать локальные данные задачи, предоставляемые пользователем.

## Child tasks

Асинхронная функция может создать дочернюю задачу.
Дочерние задачи наследуют часть структуры своей родительской, включая ее приоритет, но могут выполняться одновременно с ней.

## Jobs

Выполнение `task` можно рассматривать как последовательность периодов, в течение которых выполнялось задание, каждый из которых заканчивается в точке приостановки или завершается. Такие периоды называются `jobs`.
`Jobs` - это основные юниты планируемой работы в системе. Они также являются примитивом, с помощью которого асинхронные функции взаимодействуют с основным синхронным миром.
По большей части программистам не приходится работать непосредственно с `jobs`, если только они не реализуют кастомный `executor`.

## Executors

`Executor` — сервис, который принимает заявку от `jobs` и организует поток для выполнения.
Система предполагает, что `executors` надежны и никогда не откажутся от выполнения `job`.

`Async` функция, которая выполняется, всегда знает на каком `executor` она запущена.
Это позволяет функции избежать ненужной приостановки при вызове того же `executor`, а так же позволяет продолжить выполнение на исходном `executor`.

`Executor` называется __exclusive__ если переданные ему `jobs` никогда не будут выполняться `concurrently`.
По умолчанию Swift предоставляет реализацию `executor`, но `actor` и `global actor` можно предоставить кастомную реализацию.
Как правило, большинству разработчикам не нужно взаимодействовать с `executor` напрямую, они используют их неявно.

## Task priorities

`task` ассоциируется с установленным приоритетом.
Приоритет задачи может информировать `executor`: как и когда планировать выполнение переданных `tasks`. An executor may utilize priority information to attempt to run higher priority tasks first, and then continuing to serve lower priority tasks. It may also use priority information to affect the platform thread priority.
Точная семантика обработки приоритета, зависит от конкретной платформы и конкретной реализации `executor`.
Дочерние задачи автоматически наследуют приоритет родительской задачи. Отделенные задачи не наследуют приоритет (или любую другую информацию), поскольку семантически не имеют родительской задачи.

Приоритет задачи не обязательно должен совпадать с приоритетом `executor`, например: UI поток на платформах Apple является `executor` с высоким приоритетом.
Любая задача переданная в UI thread будет выполняться с высоким приоритетом в течении всего времени выполнения.
Это помогает гарантировать, что UI thread будет доступен для выполнения более приоритетной `task`, если она будет представлена позже.

## Priority Escalation

В некоторых ситуациях приоритет задачи может быть повышен, чтобы избежать инверсии приоритетов:

- Если `task` выполняется от actor и task с высоким приоритетом встала в очередь actor, то `task` может временно выполняться с тем же приоритетом, что и задача с высоким приоритетом.
Не влияет на дочерние задачи.
- Если `task` создана во время обработки `task` и `task` с высоким приоритетом ожидает завершения, то приоритет `task` будет повышен постоянно, чтобы соответствовать задаче с высоким приоритетом.
Не влияет на дочерние задачи.


