## Введение

[`async`/`await`](AsyncAwait.md) — это механизм для написания понятного и производительного асинхронного кода.
Асинхронные функции (обозначенные `async`) могут оставить поток, на котором они выполняются, в любой заданной точке приостановки (обозначенной `await`), что необходимо для построения `highly-concurrent` систем.

Proposal по `async`/`await` не знакомит с понятием `concurrency` *как таковым*: игнорируя suspension points в `async` функции, выполнение будет таким же, как в синхронной.
Данный proposal вводит поддержку для [structured concurrency](https://en.wikipedia.org/wiki/Structured_concurrency) в Swift, включая concurrent выполнение асинхронного кода с более удобной, предсказуемой моделью и эффективной реализацией.

## Мотивация

На простом примере, приготовим ужин, асинхронно:

```swift
func chopVegetables() async throws -> [Vegetable] { ... }
func marinateMeat() async -> Meat { ... }
func preheatOven(temperature: Double) async throws -> Oven { ... }

// ...

func makeDinner() async throws -> Meal {
  let veggies = try await chopVegetables()
  let meat = await marinateMeat()
  let oven = try await preheatOven(temperature: 350)

  let dish = Dish(ingredients: [veggies, meat])
  return try await oven.cook(dish, duration: .hours(3))
}
```

Каждый шаг в приготовлении ужина — асинхронная операция, поэтому существует несколько suspention point.
В ожидании нарезки овощей, `makeDinner` не будет блокировать поток. Функция приостановится, пока овощи не готовы, а затем возобновится.
Возможно, множество готовящихся ужинов на разных стадиях и большинство из них будут приостановлены до завершения текущего шага.

Несмотря на `async` вызовы, приготовление остается последовательным. Сначала ждем нарезки овощей, затем мариновки мяса с овощами, далее разогреть духовку и только сейчас приступить к приготовлению.
К тому времени, посетители будут голодны и недовольны такой скоростью приготовления.

Для ускорения процесса будет делать некоторые действия одновременно. Овощи можно нарезать во время мариновки мяса и в это же время разогреем духовку.
Иногда между задачами существует зависимость: как только овощи и мясо будут готовы, мы можем соединить их в блюдо, но не можем поставить это блюдо в духовку, пока духовка не нагрелась.
Все эти задачи являются одной большой задачей по приготовлению ужина. При выполнении всех задач, ужин будет подан.

Данный proposal представляет инструменты для разделения задач на сопрограммы (более мелкие задачи), выполняя задачи конкурентно, что позволит задачам ждать завершения друг друга и эффективно управлять общим ходом выполнения задачи.

## Structured concurrency

Любая concurrency система должна предоставлять базовый набор инструментов. Должен быть способ создания нового потока, который будет `concurrency` выполняться с уже существующими.
Также, должен быть способ заставить поток ждать до сигнала другого потока о продолжении работы. Благодаря таким мощным инструментам, можно написать сложные системы.
В свою очередь, такие инструменты примитивны: дают мало возможностей и ограниченную поддержку.

Представим функцию, которая выполняет тяжелую работу на `CPU`. Оптимизировав функцию, мы разделили работу на два ядра.
Тепер функция создает новый поток, выполняет **1/2** работы в каждом, а затем заставляет исходный поток ждать завершения нового потока.
Существует взаимосвязь между работой, выполняемой этими двумя потоками, но система об этом не знает. Это значительно усложняет решение системных проблем.

Существует операция с высоким приоритетом, которая требует от функции ускориться и завершить работу.
Операция может знать, что нужно повысить приоритет первого потока, но на деле нужно повысить на обоих потоках.
В лучшем случае она не будет повышать приоритет второго потока, пока первый поток не начнет его ждать.
Данную задачу легко решить в текуйщей, узкой ситуации, позволив функции создать второй поток, но это не является универсальным решением.

`Structured concurrency` решает эту проблему, предлагая программистам организовать использование конкурентности в виде высокоуровневых и их дочерних задач.
Такие `task` являются основным элементом конкурентности, чем более низкоуровневые потоки.
`Structured concurrency` позволяет информации естественным образом перемещаться вверх/вниз по иерархии задач, что в противном случае потребовало бы хорошей поддержки каждого уровня абстракции и при каждом переходе между потоками.
В свою очередь, позволяет относительно легко решать многие проблемы высокого уровня.

Например:

1. Часто необходимо ограничить затрачиваемое время на выполнение задачи. Некоторые API поддерживают установку timeout, но требуется поразмыслить, как правильно передать timeout через каждый уровень абстракции.
Разработчики хотят передавать тайм-ауты в виде относительной длительности (например, 20 мс), но правильное представление для библиотек - это абсолютный срок (например, now() + 20 мс).
При `structured concurrency`, дедлайн можно установить для task и передать через произвольные уровни API, включая дочерние таски.

2. Возможность отменить активную задачу. Асинхронные интерфейсы, который поддерживают отмену задачи, обычно реализуют это с помощью возврата токена, который вызывает некую функцию `cancel()`.
Часто такой отмены нет, потому что это усложняет проектирование дизайна API и добавляет инженерные проблемы для программы.
Такая возможность есть в `structured concurrency`, в том числе и для дочерних задач. API поддерживает обработку на такое событие.

3. Часто графические интерфейсы полагаются на приоритет задачи для своевременного обновления и реагирование на события.
В `structured concurrency` дочерние задачи наследуют прииоритет от родительской.
> ⚠️ Более того, в ситуации, когда задача с более высоким приоритетом ожидает завершения задачи с более низким приоритетом, приоритет может быть повышен.

4. 



