## Введение

В современной разработке на языке Swift мы часто прибегаем к использованию асинхронной работы, используя замыкания и completion handlers, но с этими API трудно работать.
Особенно заметно, когда в коде содержится много асинхронных операций, требуется обработать ошибки и тем самым усложняется control flow между вызовами.

Данная конструкция вводит модель корутин (`coroutine`) в Swift.
В функции можно использовать ключевое слово `async`, позволяя вам проектировать более комплексную/сложную логику, включая асинхронные операции, используя обычный control flow механизм.
За преобразование асинхронный функций в набор замыканий(appropriate set of closures) и машинное представление отвечает компилятор.

Данный файл описывает семантику и проблемы, но не `concurrency`.
Concurrency рассматривается в введении `structured concurrency`, which associates asynchronous functions with concurrently-executing tasks and provides APIs for creating, querying, and cancelling tasks.

## Мотивация: Completion handlers не удобны

При асинхронном программировании с помощью `explicit callbacks` (также completion handlers) появляется несколько проблем, описанных ниже.
Асинхронные функции служат решением этих проблем. С `async` функциями можно писать код в обычном стиле.

### Проблема #1: Pyramid of doom (Пирамида судьбы)

Последовательность асинхронных выражений часто требует глубоко вложенных замыканий:

```swift
// Код уходит в глубину, вправо
func processImageData1(completionBlock: (_ result: Image) -> Void) {
    loadWebResource("dataprofile.txt") { dataResource in
        loadWebResource("imagedata.dat") { imageResource in
            decodeImage(dataResource, imageResource) { imageTmp in
                dewarpAndCleanupImage(imageTmp) { imageResult in
                    completionBlock(imageResult)
                }
            }
        }
    }
}

processImageData1 { image in
    display(image)
}
```

Такая пирамида судьбы значительно усложняет написание, чтение и отслеживание выполняемого кода. Допольнительно, используется стопка из замыканий.

### Проблема #2: Обработка ошибок

Используя callbacks становится значительно трудней обрабатывать ошибки. В Swift 2 появилась модель обработки ошибок для синхронного кода, но интерфейсы на основе callbacks не получают от нее никаких преимуществ:

```swift
// (2a) Using a `guard` statement for each callback:
func processImageData2a(completionBlock: (_ result: Image?, _ error: Error?) -> Void) {
    loadWebResource("dataprofile.txt") { dataResource, error in
        guard let dataResource = dataResource else {
            completionBlock(nil, error)
            return
        }
        loadWebResource("imagedata.dat") { imageResource, error in
            guard let imageResource = imageResource else {
                completionBlock(nil, error)
                return
            }
            decodeImage(dataResource, imageResource) { imageTmp, error in
                guard let imageTmp = imageTmp else {
                    completionBlock(nil, error)
                    return
                }
                dewarpAndCleanupImage(imageTmp) { imageResult, error in
                    guard let imageResult = imageResult else {
                        completionBlock(nil, error)
                        return
                    }
                    completionBlock(imageResult)
                }
            }
        }
    }
}

processImageData2a { image, error in
    guard let image = image else {
        display("No image today", error)
        return
    }
    display(image)
}
```

### Проблема #3: Выполнение условий сложно и чревато ошибками

Проходить по условиям асинхронной функции - это большая проблема.
Предположим, что нам нужно при появлении «смахнуть» изображение, но иногда нужно сделать асинхронный вызов для декодирования изображения, прежде чем мы сможем выполнить свитчинг/условие.
Возможно, лучшим подходом к структурированию этой функции является запись кода `swizzling` в вспомогательное замыкание, которое условно перехватывается в обработчике завершения:


```swift
func processImageData3(recipient: Person, completionBlock: (_ result: Image) -> Void) {
    let swizzle: (_ contents: Image) -> Void = {
      // ... continuation closure that calls completionBlock eventually
    }
    if recipient.hasProfilePicture {
        swizzle(recipient.profilePicture)
    } else {
        decodeImage { image in
            swizzle(image)
        }
    }
}
```

### Проблема  #4: Легко наделать ошибок

Можно выйти из функции раньше забыв вызвать  `completion handler`
Если мы забыли это сделать, то становиться сложнее дебажить данную функцию:

```swift
func processImageData4a(completionBlock: (_ result: Image?, _ error: Error?) -> Void) {
    loadWebResource("dataprofile.txt") { dataResource, error in
        guard let dataResource = dataResource else {
            return // <- забыли вызвать блок
        }
        loadWebResource("imagedata.dat") { imageResource, error in
            guard let imageResource = imageResource else {
                return // <- забыли вызвать блок
            }
            ...
        }
    }
}
```

К счастью, вызов оператора `guard` в некоторой степени защищает от возвращаемого значения, но это не всегда актуально.

### Проблема #5: Большинство completion handlers не удобны, поэтому множество APIs являются синхронными

Трудно оценить количество, но некоторые разработчики считают, чтобы использование асинхронных API совмество с completion handlers значительно затрудняет написание кода, поэтому используют синхронный подход.
Это приводит к проблемам с производительностью, отзывчивостью и плавности UI.

## Решение: async/await

Асинхронные функции, известные как `async/await`, позволяют писать код в том же стиле, как и обычный синхронный код.
Более того, это сразу решает описанные проблемы выше, позволяя разработчикам использовать те же конструкции языка, доступные для синхронного кода.

Использование async/await также естественным образом сохраняет семантическую структуру кода, предоставляя информацию, необходимую как минимум для трех улучшений языка:

1. Более лучшая производительность
2. Более современные инструменты для отладки, профайлинга и исследования кода
3. Фундамент для concurrency фич, таких как приоритет (`task priority`) и отмена задач `task`.

Пример из предыдущего раздела демонстрирует, как async/await радикально упрощает асинхронный код:

```swift
func loadWebResource(_ path: String) async throws -> Resource
func decodeImage(_ r1: Resource, _ r2: Resource) async throws -> Image
func dewarpAndCleanupImage(_ i : Image) async throws -> Image

func processImageData() async throws -> Image {
  let dataResource  = try await loadWebResource("dataprofile.txt")
  let imageResource = try await loadWebResource("imagedata.dat")
  let imageTmp      = try await decodeImage(dataResource, imageResource)
  let imageResult   = try await dewarpAndCleanupImage(imageTmp)
  return imageResult
}
```

Многие описания `async/await` рассматривают его через общий механизм реализации: пропуск компилятора, который делит функцию на несколько компонентов.
Это важно на низком уровне абстракции, чтобы понять, как работает механизм.
Думайте об асинхронной функции как об обычной функции, которая обладает особой способностью оставить/отказаться от своего потока. Асинхронные функции обычно не используют эту способность напрямую, вместо этого они делают вызовы, и иногда эти вызовы требуют, чтобы они отказались от своего потока и ждали, пока что-то произойдет.
Когда «это что-то произойдет», функция возобновит выполнение.

Поскольку асинхронные функции должны уметь оставлять свой поток, а синхронные функции не умеют этого делать, то синхронная функция не может вызвать асинхронную функцию: асинхронная функция сможет отдать только ту часть потока, которую она занимала, а если она попытается это сделать, то вызывающая ее синхронная функция воспримет это как возврат и попытается продолжить работу, только без возвращаемого значения.
Единственным способом заставить это работать в общем случае было бы блокирование всего потока до возобновления и завершения асинхронной функции, что полностью уничтожило бы смысл асинхронных функций, а также привело бы к неприятным системным последствиям.

В свою очередь, асинхронная функция может вызывать как синхронные, так и асинхронные функции.
Вызывая синхронную функцию, она, конечно же, не может отказаться от своего потока.

> ⚠️ Асинхронные функции никогда самопроизвольно не оставляют свой поток! Оставить поток можно тогда, когда достигается точки приостановки `suspention point`.

Точка приостановки может возникнуть непосредственно внутри функции или в другой асинхронной функции, которую вызывает функция, но в любом случае функция и все вызывающие ее асинхронные функции одновременно оставляют поток.
На практике асинхронные функции компилируются специальным образом, чтобы не зависеть от потока во время асинхронного вызова.


## Suspension points

`Suspension point` (точка/момент приостановки) — это момент в выполнении `async` функции, в котором оставляется текущий поток.
Основной формой момента приостановки является вызов асинхронной функции, связанной с другим контекстом выполнения.
Важно, чтобы момент приостановки был связан только с явными операциями.
Вызов `async` функции с ключевым словом `await` называется **потенциальным моментом приостановки**, поскольку статически неизвестно, приостановятся ли она на самом деле.

Зависит от
1. кода, не видимого в месте вызова. Например, вызывающая сторона может зависеть от асинхронного ввода-вывода.
2. динамических условий. Например, нужно ли ждать завершения асинхронного ввода-вывода.

Требование указывать ключевое слово `await` такая же необходимость, как и требование указывать `try` в функциях, которые могут вернуть ошибку, обозначенных `throws`.
Если `async` функция работает в заданном контексте, который защищен `serial queue` (последовательной очередью), достигая момента остановки, это означает другой код может чередоваться на той же последовательной очереди.
Классическим примером служит проектирование банка: если депозит зачисляется на один счет, но операция приостанавливается перед обработкой обнала, это создает окно, в котором эти средства могут быть дважды потрачены.
На примере UI: `suspention point` - это момент, в которых создается UI, а затем приостанавливают создание, могут столкнуться с мерцающим, частично построенным пользовательским интерфейсом. 

Несмотря на то, что потенциальный `suspention point`(момент приостановки) может появляться только в явно обозначеной асинхронной функции, сложные/длительные вычисления все равно могут блокировать потоки.
Это происходит при вызове синхронной функции, которая занимается тяжелыми операциями/вычислениями.
В любом случае поток не может чередовать код во время выполнения этих вычислений, что обычно является правильным выбором с точки зрения корректности, но может стать проблемой масштабируемости.
Асинхронные функции, которым выполняют интенсивные вычисления, должны выполняться в отдельном контексте. Когда это невозможно, существуют библиотечные средства для искусственного приостановления и обеспечения чередования других операций.

Нужно избегать вызова функции, которые могут заблокировать поток `async` функции.
