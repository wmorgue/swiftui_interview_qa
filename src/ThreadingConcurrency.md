## В чём разница между Thread и Task?

У процессора есть [регистры][processor_register], которые, по сути, являются его «локальными переменными». Все, что процессор хочет обработать, он загружает из памяти (RAM) в регистры, выполняет операции, а затем возвращает обратно в память. Один из регистров называется «[Счетчик команд][instruct_pointer]» (счетчик программ, на англ. Instruction Pointer/Program counter), который указывает, какую инструкцию нужно выполнять следующей. Существует фиксированное кол-во регистров, а «локальных переменных» может быть неограниченное кол-во, поэтому для хранения «локальных переменных», которые в данный момент не находятся в регистре, существует специальная область памяти под названием Stack (стэк).

Thread (поток) это:

- Состояние всех регистров
- Stack (стэк)
- Указатель, по которому ОС (в частности планировщик ядра) может следить за ним
- Метаданные и дополнительные сведения о состоянии (приоритет и т.д.)


Если у вас больше одного потока (многопоточная программа), то у вас более одного счетчика команд, более одного набора регистров и более одного стэка. Это все, что нужно для работы одного процессора (ядра процессора, что почти одно и тоже).
Каждая программа имеет как минимум один поток. Выполняя 2-е программы одновременно, вы используете 2-а ядра процессора, так же как и одна программа, но с двумя потоками.

Многозадачная операционная система, коими являются большинство современных ОС, будет переключать потоки через частые интервалы времени. Это позволяет произвольному кол-ву программ или потоков работать на произвольном кол-ве ядер/процессоров. Существуют 2-а способа переключаться:

1. Поток может сообщить ОС: «я закончил, пусть работает что-то другое»
2. ОС может сообщить: «некий квант времени истек, теперь очередь чего-то другого»

Способы выше называются [кооперативной и вытесняющей][multitasking] многозадачностью соответственно. Все современные операционные системы, ориентированные на потребителя, в основном используют вытесняющую многозадачность, потому что в противном случае, программа, которая ведет себя «плохо», может помешать выполнению других программ, не сообщив о своем завершении.

**Но!** Вытесняющая многозадачность имеет некоторые существенные недостатки/затраты:

1. Переключение между потоками требует сохранения всех регистров текущего потока в память, а затем выгрузки из памяти, что приводит к затратам по времени
2. Хранение всей информации о потоке занимает память
3. Ядру ОС для отслеживания потоков требуется дополнительная память

Ответ на вопрос:

Swift Concurrency использует смешенную (гибридную) модель: существую легковесные «потокоподобные» Tasks, о которых ядро ничего не знает, а библиотека Concurrency выполняет свою собственную кооперативную многозадачность, чтобы решить, какие из них будут выполняться на небольшой горстке "настоящих" потоков с поддержкой ядра. Каждый раз, когда вы ожидаете вызов `await`, вы даете системе кооперативной многозадачности шанс сообщить: «хорошо, теперь очередь другого», т.е. вы отказываетесь от текущего потока. В литературе такую потоковую модель называют "[M:N][hybrid_model]". В модели M:N некоторое число M прикладных потоков выполнения отображаются на некоторое число N сущностей ядра или «виртуальных процессоров».

В лучшем случае, раньше требовалось много настоящих (затратных) потоков, каждый из которых выполнялся в течении короткого времени, то теперь требуется небольшое число настоящих потоков, которые выполняются столько, сколько позволяется ядро, минимизируя затраты памяти и затраты на переключения.

[processor_register]: https://ru.wikipedia.org/wiki/Регистр_процессора
[instruct_pointer]: https://ru.wikipedia.org/wiki/Счётчик_команд
[multitasking]: https://ru.wikipedia.org/wiki/Многозадачность#Совместная_или_кооперативная_многозадачность
[hybrid_model]: https://ru.wikipedia.org/wiki/Поток_выполнения#M:N_(смешанная_потоковость)
