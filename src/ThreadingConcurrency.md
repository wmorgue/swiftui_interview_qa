## Grand Central Dispatch

`libdispatch` (aka `GCD`) – библиотека предоставляющая доступ к высокоуровневому API для конкурентного выполнения задач с управлением потоками за сценой. `GCD` абстрагируется от кода управления потоками и переносит его на системный уровень, предоставляя легкий API для определения задач и их выполнения в соответствующей очереди диспетчеризации. `GCD` работает на системном уровне, таким образом он может удовлетворить потребности всех запущенных приложений на девайсе, при этом управляя ресурсами эффективно.


## Что такое dispatch queue?
`Queue` (очередь) представляет собой сущность, выполняющую задачи, поступающие на вход, на одном или множестве потоков. Очередь работает по принципу FIFO(first in, first out), таким образом первая задача на очереди будет первой направлена на выполнение на потоке.

## Что такое main thread и его использование?

В iOS главный поток приложения - это очередь, состоящая из процессов. Главный поток должен использоваться для всех View, а элементы интерфейса не должны блокироваться выполняющимися задачами. Разработчику следует избегать функций, использующих главный поток для загрузки данных, изображений и т.д.

## Существует 2 типа queue. Перечислите и расскажите.

1. `serial` – выполняет задачи последовательно (поочередно). До тех пор, пока задача не будет выполнена, поток не приступит к выполнения следующей задачи в очереди.
2. `concurrent` – выполняет задачи конкурентно. Задачи, поступающие в concurrent очередь, могут выполняться одновременно на разных потоках.

## Объясните 3 GCD queues?

GCD предоставляет 3 типа queues –

1. `Main queue`: Serial queue – работает на main thread.
2. `Global queue`: Concurrent queue – работает с разным приоритетом и доступен всей системе. 
3. `Custom queue`: Serial/ Concurrent queue.

## Что такое Quality of Service?

`Quality of Service`(QOS) - это приоритет выполнения задачи в `GCD`. Если `task` имеет более высокий `qos`, чем другие, оно будет обработано раньше, чем `task` с более низким приоритетом.

`QOS` ранжируется от высшего к низшему:

1. `User Interactive`: Задача, которая запускается в основном потоке, например, анимация или операции рисования.
2. `User Initiated`: Задача, которую запускает пользователь и которая должна дать немедленные результаты. Эта задача должна быть завершена, чтобы пользователь мог продолжить работу.
3. `Utility`: Задача, которая может занять некоторое время и не требует немедленного завершения. Аналогично индикаторам выполнения и импорту данных.
4. `Background`: Данная задача не видна пользователю. Резервное копирование, синхронизация, индексирование и т.д.


## Объясните data race?

`Data Race` - это ситуация, когда две инструкции из двух разных потоков пытаются получить доступ к одному и тому же участку памяти, при это один из этих доступов на запись и между ними нет никакой синхронизации.



## Объясните race condition?

Это семантическая ошибка, возникающая во времени или порядке событий, которая приводит к неверному поведению программы. Race Condition может быть вызвана Data Race, но может быть вызвана и другими причинами.

## Объясните deadlock?

`Deadlock` (тупик) возникает, когда две, а иногда и больше задач ожидают завершения другой задачи, но ни одна из них так и не завершается. Первое действие не может быть закончено, потому что оно ожидает окончания второго. А второе не может закончено, потому что оно ожидает окончания первого.

## Что такое priority inversion?

`Priority inversion` (инверсия приоритетов) - это критическое состояние в потоках, когда поток с низким приоритетом блокирует выполнение потока с высоким приоритетом и делает назначенные приоритеты бессмысленными для потока.

## Объясните NSOperation?

`NSOperation` построен поверх `libdispatch` для упрощения работы с несколькими потоками. Используя `NSOperation` можно добавить зависимость для различных операций, повторно использовать, отменить или приостановить их.

## Объясните ThreadPool?

`ThreadPool` — пул потоков, которые повторно используют фиксированное число поток для выполнения конкретной задачи.

## Что такое Semaphore?

`Semaphore` предоставляет нам возможность контролировать доступ нескольких поток к общему ресурсу. Семафор состоит из очереди потоков и счетчика значений. Счетчик значений используется семафором, чтобы решить, должен ли поток получить доступ к общему ресурсу или нет. Счетчик значений изменяется при вызове функций `signal()` или `wait()`.

## Что такое Task?

`Task` - юнит асинхронной работы, в котором выполняется `async` функция:

```swift
@frozen struct Task<Success, Failure> where Success : Sendable, Failure : Error
```


`Task` позволяют создавать конкурентное окружение из не-конкурентных методов с помощью вызова `async/await`.
Задача выполняется немедленно после объявления и не требует явного запуска.
Задачи имеют приоритет, их можно отменять, и они могут находиться в трёх состояниях - приостановленные, выполняющиеся и завершенные. Могут быть структурированными и неструктурированными.


## Что такое actor?

actor — reference type, который защищает доступ к изменяемому состоянию и объявляется с помощью ключевого слова `actor`. Тип данных, который можно безопасно использовать в конкурентной среде. Содержит следующие характеристики:

1. Имеют собственное изолированное состояние.
2. Может содержать логику для изменения собственного состояния.
3. Может общаться с другими участниками только асинхронно (через их адреса).
4. Может создавать других дочерних акторов (в данном случае нас это не особо волнует).

## Расскажите о ключевом слове await

`await` — это специальная пометка, которая говорит о том, что в этом месте может быть `suspension point`.

`Suspension points`(точки приостановки) – динамическая концепция всей программы, которая гласит: существуют места, которые могут фактически приостанавливать выполнение задачи и оставить поток.

`Potential suspension points` - are the static, conservative, function-local view of suspension points: they're the points in the function where a suspension could potentially occur and therefore the function ought to be prepared to abandon the thread. Any dynamic suspension point is always "inside" a potential suspension point from the perspective of every async function on that task: all of the outer functions must be awaiting an asynchronous call, and the innermost function must be awaiting at the actual dynamic suspension point. From all of those functions' local perspectives, the exact reason for the suspension (which may be N levels of call deep) is much less important than the fact that a suspension is possible at that point in their execution.

<!-- ## В чём разница между Thread и Task?

У процессора есть [регистры][processor_register], которые, по сути, являются его «локальными переменными». Все, что процессор хочет обработать, он загружает из памяти (RAM) в регистры, выполняет операции, а затем возвращает обратно в память. Один из регистров называется «[Счетчик команд][instruct_pointer]» (счетчик программ, на англ. Instruction Pointer/Program counter), который указывает, какую инструкцию нужно выполнять следующей. Существует фиксированное кол-во регистров, а «локальных переменных» может быть неограниченное кол-во, поэтому для хранения «локальных переменных», которые в данный момент не находятся в регистре, существует специальная область памяти под названием Stack (стек).

Thread (поток) это:

- Состояние всех регистров
- Stack (стек)
- Указатель, по которому ОС (в частности планировщик ядра) может следить за ним
- Метаданные и дополнительные сведения о состоянии (приоритет и т.д.)


Если у вас больше одного потока (многопоточная программа), то у вас более одного счетчика команд, более одного набора регистров и более одного стека. Это все, что нужно для работы одного процессора (ядра процессора, что почти одно и тоже).
Каждая программа имеет как минимум один поток. Выполняя 2-е программы одновременно, вы используете 2-а ядра процессора, так же как и одна программа, но с двумя потоками.

Многозадачная операционная система, коими являются большинство современных ОС, будет переключать потоки через частые интервалы времени. Это позволяет произвольному кол-ву программ или потоков работать на произвольном кол-ве ядер/процессоров. Существуют 2-а способа переключаться:

1. Поток может сообщить ОС: «я закончил, пусть работает что-то другое»
2. ОС может сообщить: «некий квант времени истек, теперь очередь чего-то другого»

Способы выше называются [кооперативной и вытесняющей][multitasking] многозадачностью соответственно. Все современные операционные системы, ориентированные на потребителя, в основном используют вытесняющую многозадачность, потому что в противном случае, программа, которая ведет себя «плохо», может помешать выполнению других программ, не сообщив о своем завершении.

**Но!** Вытесняющая многозадачность имеет некоторые существенные недостатки/затраты:

1. Переключение между потоками требует сохранения всех регистров текущего потока в память, а затем выгрузки из памяти, что приводит к затратам по времени
2. Хранение всей информации о потоке занимает память
3. Ядру ОС для отслеживания потоков требуется дополнительная память

Ответ на вопрос:

Swift Concurrency использует смешенную (гибридную) модель: существую легковесные «потокоподобные» Tasks, о которых ядро ничего не знает, а библиотека Concurrency выполняет свою собственную кооперативную многозадачность, чтобы решить, какие из них будут выполняться на небольшой горстке "настоящих" потоков с поддержкой ядра. Каждый раз, когда вы ожидаете вызов `await`, вы даете системе кооперативной многозадачности шанс сообщить: «хорошо, теперь очередь другого», т.е. вы отказываетесь от текущего потока. В литературе такую потоковую модель называют "[M:N][hybrid_model]". В модели M:N некоторое число M прикладных потоков выполнения отображаются на некоторое число N сущностей ядра или «виртуальных процессоров».

В лучшем случае, раньше требовалось много настоящих (затратных) потоков, каждый из которых выполнялся в течении короткого времени, то теперь требуется небольшое число настоящих потоков, которые выполняются столько, сколько позволяется ядро, минимизируя затраты памяти и затраты на переключения.

[processor_register]: https://ru.wikipedia.org/wiki/Регистр_процессора
[instruct_pointer]: https://ru.wikipedia.org/wiki/Счётчик_команд
[multitasking]: https://ru.wikipedia.org/wiki/Многозадачность#Совместная_или_кооперативная_многозадачность
[hybrid_model]: https://ru.wikipedia.org/wiki/Поток_выполнения#M:N_(смешанная_потоковость) -->
