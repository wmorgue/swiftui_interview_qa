## Grand Central Dispatch

`libdispatch` (aka `GCD`) – библиотека предоставляющая доступ к высокоуровневому API для конкурентного выполнения задач с управлением потоками за сценой. `GCD` абстрагируется от кода управления потоками и переносит его на системный уровень, предоставляя легкий API для определения задач и их выполнения в соответствующей очереди диспетчеризации. `GCD` работает на системном уровне, таким образом он может удовлетворить потребности всех запущенных приложений на девайсе, при этом управляя ресурсами эффективно.


## Что такое dispatch queue?
`Queue` (очередь) представляет собой сущность, выполняющую задачи, поступающие на вход, на одном или множестве потоков. Очередь работает по принципу FIFO(first in, first out), таким образом первая задача на очереди будет первой направлена на выполнение на потоке.

## Что такое main thread и его использование?

В iOS главный поток приложения - это очередь, состоящая из процессов. Главный поток должен использоваться для всех View, а элементы интерфейса не должны блокироваться выполняющимися задачами. Разработчику следует избегать функций, использующих главный поток для загрузки данных, изображений и т.д.

## Существует 2 типа queue. Перечислите и расскажите.

1. `serial` – выполняет задачи последовательно (поочередно). До тех пор, пока задача не будет выполнена, поток не приступит к выполнения следующей задачи в очереди.
2. `concurrent` – выполняет задачи конкурентно. Задачи, поступающие в concurrent очередь, могут выполняться одновременно на разных потоках.

## Объясните 3 GCD queues?

GCD предоставляет 3 типа queues –

1. `Main queue`: Serial queue – работает на main thread.
2. `Global queue`: Concurrent queue – работает с разным приоритетом и доступен всей системе. 
3. `Custom queue`: Serial/ Concurrent queue.

## Что такое Quality of Service?

`Quality of Service`(QOS) - это приоритет выполнения задачи в `GCD`. Если `task` имеет более высокий `qos`, чем другие, оно будет обработано раньше, чем `task` с более низким приоритетом.

`QOS` ранжируется от высшего к низшему:

1. `User Interactive`: Задача, которая запускается в основном потоке, например, анимация или операции рисования.
2. `User Initiated`: Задача, которую запускает пользователь и которая должна дать немедленные результаты. Эта задача должна быть завершена, чтобы пользователь мог продолжить работу.
3. `Utility`: Задача, которая может занять некоторое время и не требует немедленного завершения. Аналогично индикаторам выполнения и импорту данных.
4. `Background`: Дананя задача не видна пользователю. Резервное копирование, синхронизация, индексирование и т.д.


## Объясните data race?

`Data Race` - это ситуация, когда две инструкции из двух разных потоков пытаются получить доступ к одному и тому же участку памяти, при это один из этих доступов на запись и между ними нет никакой синхронизации.



## Объясните race condition?

Это семантическая ошибка, возникающая во времени или порядке событий, которая приводит к неверному поведению программы. Race Condition может быть вызвана Data Race, но может быть вызвана и другими причинами.

## Объясните deadlock?

`Deadlock` (тупик) возникает, когда две, а иногда и больше задач ожидают завершения другой задачи, но ни одна из них так и не завершается. Первое действие не может быть закончено, потому что оно ожидает окончания второго. А второе не может закончено, потому что оно ожидает окончания первого.

## Что такое priority inversion?

`Priority inversion` (инверсия приоритетов) - это критическое состояние в потоках, когда поток с низким приоритетом блокирует выполнение потока с высоким приоритетом и делает назначенные приоритеты бессмысленными для потока.


<!-- ## В чём разница между Thread и Task?

У процессора есть [регистры][processor_register], которые, по сути, являются его «локальными переменными». Все, что процессор хочет обработать, он загружает из памяти (RAM) в регистры, выполняет операции, а затем возвращает обратно в память. Один из регистров называется «[Счетчик команд][instruct_pointer]» (счетчик программ, на англ. Instruction Pointer/Program counter), который указывает, какую инструкцию нужно выполнять следующей. Существует фиксированное кол-во регистров, а «локальных переменных» может быть неограниченное кол-во, поэтому для хранения «локальных переменных», которые в данный момент не находятся в регистре, существует специальная область памяти под названием Stack (стэк).

Thread (поток) это:

- Состояние всех регистров
- Stack (стэк)
- Указатель, по которому ОС (в частности планировщик ядра) может следить за ним
- Метаданные и дополнительные сведения о состоянии (приоритет и т.д.)


Если у вас больше одного потока (многопоточная программа), то у вас более одного счетчика команд, более одного набора регистров и более одного стэка. Это все, что нужно для работы одного процессора (ядра процессора, что почти одно и тоже).
Каждая программа имеет как минимум один поток. Выполняя 2-е программы одновременно, вы используете 2-а ядра процессора, так же как и одна программа, но с двумя потоками.

Многозадачная операционная система, коими являются большинство современных ОС, будет переключать потоки через частые интервалы времени. Это позволяет произвольному кол-ву программ или потоков работать на произвольном кол-ве ядер/процессоров. Существуют 2-а способа переключаться:

1. Поток может сообщить ОС: «я закончил, пусть работает что-то другое»
2. ОС может сообщить: «некий квант времени истек, теперь очередь чего-то другого»

Способы выше называются [кооперативной и вытесняющей][multitasking] многозадачностью соответственно. Все современные операционные системы, ориентированные на потребителя, в основном используют вытесняющую многозадачность, потому что в противном случае, программа, которая ведет себя «плохо», может помешать выполнению других программ, не сообщив о своем завершении.

**Но!** Вытесняющая многозадачность имеет некоторые существенные недостатки/затраты:

1. Переключение между потоками требует сохранения всех регистров текущего потока в память, а затем выгрузки из памяти, что приводит к затратам по времени
2. Хранение всей информации о потоке занимает память
3. Ядру ОС для отслеживания потоков требуется дополнительная память

Ответ на вопрос:

Swift Concurrency использует смешенную (гибридную) модель: существую легковесные «потокоподобные» Tasks, о которых ядро ничего не знает, а библиотека Concurrency выполняет свою собственную кооперативную многозадачность, чтобы решить, какие из них будут выполняться на небольшой горстке "настоящих" потоков с поддержкой ядра. Каждый раз, когда вы ожидаете вызов `await`, вы даете системе кооперативной многозадачности шанс сообщить: «хорошо, теперь очередь другого», т.е. вы отказываетесь от текущего потока. В литературе такую потоковую модель называют "[M:N][hybrid_model]". В модели M:N некоторое число M прикладных потоков выполнения отображаются на некоторое число N сущностей ядра или «виртуальных процессоров».

В лучшем случае, раньше требовалось много настоящих (затратных) потоков, каждый из которых выполнялся в течении короткого времени, то теперь требуется небольшое число настоящих потоков, которые выполняются столько, сколько позволяется ядро, минимизируя затраты памяти и затраты на переключения.

[processor_register]: https://ru.wikipedia.org/wiki/Регистр_процессора
[instruct_pointer]: https://ru.wikipedia.org/wiki/Счётчик_команд
[multitasking]: https://ru.wikipedia.org/wiki/Многозадачность#Совместная_или_кооперативная_многозадачность
[hybrid_model]: https://ru.wikipedia.org/wiki/Поток_выполнения#M:N_(смешанная_потоковость) -->
