# Swift iOS Interview Questions & Answers

## Что такое вывод типов (type inference)?

[Возможность компилятора][type_inference] самому логически вывести тип значения у выражения:

```swift
// константа `myStr` имеет тип данных `String`
let myStr = "Hello, World!"

// явно выводим тип данных
let myStr: String = "Hello, World!"
```

## Что такое Generics (обобщенное программирование)?

[Парадигма программирования][generics], заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само описание. Парадигма позволяет писать код, который избавляет от дублирования и выражает цели в ясном, абстрактном подходе:

```swift
// T — Generic тип
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  (a, b) = (b, a)
}

var min = UInt8.min // 0
var max = UInt8.max // 255

swapTwoValues(&min, &max)

var first = "first"
var second = "second"

swapTwoValues(&first, &second)
```

## Что такое Протоколы (protocols)?

[Протокол][protocols] - это набор методов, свойств (проперти) и других требований, которые соответствуют определенной задаче или функциональности. Протокол может быть принят классом, структурой или перечислением для реализации (implementation) этих требований.

```swift
protocol Human {
  var givenName: String { get }
}

struct Person: Human {
  var givenName: String
}

let nick = Person(givenName: "Nick") // nick.givenName это "Nick"
```

> ⚠️ Протокол не содержит реализаций (implementation) свойств и методов. Проперти не содержит данных, а тело метода пустое. Тип, который наследуется от протокола, должен реализовывать все проперти и методы, которые присутствуют в данном протоколе.


## Что такое Tuples (тупл, кортёж)?

Список типов, который разделен запятыми и заключен в круглые скобки.

```swift
let coordinates: (Int, Int) = (2, 3)

var someTuple = (top: 10, bottom: 12)  // someTuple is of type (top: Int, bottom: Int)
someTuple = (top: 4, bottom: 42) // OK: names match
someTuple = (9, 99)              // OK: names are inferred
someTuple = (left: 5, right: 5)  // Error: names don't match
```

## Что такое Optional? (опциональное значение)

Тип данных, который предоставляет обернутое значение или `nil` | `.none`, отсутствие значения. Иными словами, значение может быть или не может. Можно записать как `Optional<Int>`, но предпочтительна более коротка форма `Int?`:

```swift
let shortForm: Int? = Int("42")
let longForm: Optional<Int> = Int("42")

let number: Int? = Optional.some(42)
let noNumber: Int? = Optional.none
print(noNumber == nil) // true
```

Развернуть (получить) значение можно с помощью:
- `Optional Binding` (if let, guard let, switch)

```swift
if let starPath = imagePaths["star"] {
    print("The star image is at '\(starPath)'")
} else {
    print("Couldn't find the star image")
}
```

- `Optional Chaining` используя опциональный постфикс оператор (postfix ?)

```swift
if imagePaths["star"]?.hasSuffix(".png") == true {
    print("The star image is in PNG format")
}
```

- `Nil-Coalescing Operator ??`, предоставляя дефолтное значение

```swift
let defaultImagePath = "/images/default.png"
let heartPath = imagePaths["heart"] ?? defaultImagePath
print(heartPath)
```

- `Unconditional (Force) Unwrapping !`

```swift
let number = Int("42")!
print(number)
```

> ⚠️ Принудительная развертка выражения со значением `nil` приведет к `runtime error`.


## Что такое `Inout` и как его использовать?

По умолчанию все параметры в функциях являются неизменяемыми константами (`immutable let`). Это означает, что ты не можешь изменить значение параметра, т.е.  если ты захочешь изменить значение параметра функции в теле самой функции, то получишь ошибку компиляции. Если возникла такая необходимость, то используй ключевое слово `inout` между параметром и типом данных:

```swift
func reverseName(_ name: inout String) {
  name = "github.com/" + String(name.reversed())
}

var githubUser = "@wmorgue"
print(githubUser) // @wmorgue
reverseName(&githubUser) // github.com/eugromw@
print(githubUser)
```

> ⚠️ Ты не можешь установить дефолтное значение `_ name: inout String = "@wmorgue"`.
Когда передаешь значение в `inout` параметр, то используй амперсанд `&` перед выражением.


## Разница между Self и self?

`Self` указывает на тип протокола, класса, структуры.

`self` указывает на значение, которое оно содержит.


## Что такое lazy? Ленивое свойство хранения и когда оно используется?

Ленивое свойство хранения - свойство, начальное значение которого не вычисляется до первого использования. Индикатор ленивого свойства - ключевое слово `lazy`.

> ⚠️ Всегда объявляйте свойства ленивого хранения как переменные `var`, потому что ее значение может быть не получено до окончания инициализации.


## Что такое defer?

Оператор `defer` — это блок кода, который будет выполнятся в случае выхода из текущей области видимости.

## Преимущества использовать guard statement?

Два основных преимущества использовать `guard`:

1. Избежать пирамиду судьбы (pyramid of doom). Множество вложенных `if let`, уходящих в глубину.
2. Оператор предоставляет ранний выход из функции с помощью `return`.

## Что такое вариативный (variadic) параметр?

Вариативный параметр в функции принимает 0 или несколько значений определенного типа:

```swift
// вариативный параметр может принимать любое кол-во чисел
func redeemVouchers(_ greetings: String, voucherValues: Int...) -> String {
  let voucherText = voucherValues.count > 0 ? " You have redeemed " + "\(voucherValues.reduce(0, +)) €" : ""
  return greetings + voucherText
}
// без вариативного параметра
redeemVouchers("Congratulation!") // "Congratulation!"

// несколько вариативных параметров
redeemVouchers("Congratulation!", voucherValues: 12, 23, 10) // "Congratulation! You have redeemed 45 €"

// один вариативный параметр
redeemVouchers("Congratulation!", voucherValues: 10) // "Congratulation! You have redeemed 10 €"
```

Параметр объявляется с тремя точками `...`. Вызывая функцию, ты можешь не передавать значение второму аргументу или передать несколько.

## Ключевое слово `final` перед `class`?

Добавляя ключевое слово `final` классу/членами класса, мы ограничиваем класс/метод/свойство на переопределение(overridden). Так же мы не можем наследоваться от этого класса:

```swift
final class MyClass {
  final var myVar: String = "You can't override me!"
  final func myMethod() -> Optional<Any> { nil }
  final var myComputedProperty: Int { .zero }
}
```

## В чём разница между static и final?

Статическая переменная/функция доступна всему инстансу класса. `static` используется для проперти/методов, доступ к которым можно получить без создания инстанса класса. С `final` мы не может наследоваться.


## В чём разница между open и public?

`open` позволяет другим модулям использовать класс и наследоваться от него. Члены `open` класса могут быть переопределены (be overridden) другими модулями.

`public` позволяет другим модулям использовать только `public` классы, но не может быть подклассом или переопределен другими модулями.


## В чём разница между операторами `==` и `===`?

Основное различие между двойным `=` и тройным `=` операторами в том, что оператор сравнения `==` сравнивает типы значений, чтобы проверить одинаковы ли они, а  `===` оператор сравнивает ссылочные типы, чтобы проверить, указывают ли ссылки на тот же инстанс.

## В чём разница между Thread и Task?

У процессора есть [регистры][processor_register], которые, по сути, являются его «локальными переменными». Все, что процессор хочет обработать, он загружает из памяти (RAM) в регистры, выполняет операции, а затем возвращает обратно в память. Один из регистров называется «[Счетчик команд][instruct_pointer]» (счетчик программ, на англ. Instruction Pointer/Program counter), который указывает, какую инструкцию нужно выполнять следующей. Существует фиксированное кол-во регистров, а «локальных переменных» может быть неограниченное кол-во, поэтому для хранения «локальных переменных», которые в данный момент не находятся в регистре, существует специальная область памяти под названием Stack (стэк).

Thread (поток) это:

- Состояние всех регистров
- Stack (стэк)
- Указатель, по которому ОС (в частности планировщик ядра) может следить за ним
- Метаданные и дополнительные сведения о состоянии (приоритет и т.д.)


Если у вас больше одного потока (многопоточная програма), то у вас более одного счетчика команд, более одного набора регистров и более одного стэка. Это все, что нужно для работы одного процессора (ядра процессора, что почти одно и тоже).
Каждая программа имеет как минимум один поток. Выполняя 2-е программы одновременно, вы используете 2-а ядра процессора, так же как и одна программа, но с двумя потоками.

Многозадачная операционная система, коими являются большинство современных ОС, будет переключать потоки через частые интервалы времени. Это позволяет произвольному кол-ву программ или потоков работать на произвольном кол-ве ядер/процессоров. Существуют 2-а способа переключаться:

1. Поток может сообщить ОС: «я закончил, пусть работает что-то другое»
2. ОС может сообщить: «некий квант времени истек, теперь очередь чего-то другого»

Способы выше называются [кооперативной и вытесняющей][multitasking] многозадачностью соответственно. Все современные операционные системы, ориентированные на потребителя, в основном используют вытесняющую многозадачность, потому что в противном случае, программа, которая ведет себя «плохо», может помешать выполнению других программ, не сообщив о своем завершении.

**Но!** Вытесняющая многозадачность имеет некоторые существенные недостатки/затраты:

1. Переключение между потоками требует сохранения всех регистров текущего потока в память, а затем выгрузки из памяти, что приводит к затратам по времени
2. Хранение всей информации о потоке занимает память
3. Ядру ОС для отслеживания потоков требуется дополнительная память

Ответ на вопрос:

Swift Concurrency использует смешенную (гибридную) модель: существую легковесные «потокоподобные» Tasks, о которых ядро ничего не знает, а библиотека Concurrency выполняет свою собственную кооперативную многозадачность, чтобы решить, какие из них будут выполняться на небольшой горстке "настоящих" потоков с поддержкой ядра. Каждый раз, когда вы ожидаете вызов `await`, вы даете системе кооперативной многозадачности шанс сообщить: «ок, теперь очередь другого», т.е. вы отказываетесь от текущего потока. В литературе такую потоковую модель называют "[M:N][hybrid_model]". В модели M:N некоторое число M прикладных потоков выполнения отображаются на некоторое число N сущностей ядра или «виртуальных процессоров».

В лучшем случае, раньше требовалось много настоящих (затратных) потоков, каждый из которых выполнялся в течении короткого времени, то теперь требуется небольшое число настоящих потоков, которые выполняются столько, сколько позволяется ядро, минимизируя затраты памяти и затраты на переключения.

## Почему мы не может объявить open struct?

Потому что наследование между структурами не возможно. `open` означает, что вы можете переопределить родительский метод/проперти данного класса вне модуля.

## В чём разница между fileprivate, private и public private(set) уровнями доступа?

`fileprivate` доступен в пределах текущего файла. `private` доступен в пределах текущей структуры/класса/enum. `public private(set)` обозначает, что getter публичный, а setter приватный.

## Что такое внутренний (internal) уровень доступа?

Внутренний (internal) уровень доступа позволяет использовать свойства и методы внутри модуля, но не в любом исходном файле за пределами модуля. `internal` установлен по умолчанию и не требует явного объявления:

```swift
// записи равнозначны
var number = 5
internal var number = 5
```

## Объясните разницу между структурой и классом в Swift?

`struct` — value type. `class` — reference type.
При копировании структуры вы получаете 2 уникальных инстанса данных. При копировании класса вы получаете 2 ссылки на один инстанс данных.

## Каким простым способом можно реализовать абстракцию в проекте?

Используя протоколы и разделяя модули, например SPM.

<!--
## Что такое value/reference тип в Swift?

Дать ответ без содержания воды.
-->


<!-- Link's section  -->
[type_inference]: https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322
[generics]: https://docs.swift.org/swift-book/LanguageGuide/Generics.html
[protocols]: https://docs.swift.org/swift-book/LanguageGuide/Protocols.html
[processor_register]: https://ru.wikipedia.org/wiki/Регистр_процессора
[instruct_pointer]: https://ru.wikipedia.org/wiki/Счётчик_команд
[multitasking]: https://ru.wikipedia.org/wiki/Многозадачность#Совместная_или_кооперативная_многозадачность
[hybrid_model]: https://ru.wikipedia.org/wiki/Поток_выполнения#M:N_(смешанная_потоковость)
