## Что такое вывод типов (type inference)?

[Возможность компилятора][type_inference] самому логически вывести тип значения у выражения:

```swift
// константа `myStr` имеет тип данных `String`
let myStr = "Hello, World!"

// явно выводим тип данных
let myStr: String = "Hello, World!"
```

## Что такое Generics (обобщенное программирование)?

[Парадигма программирования][generics], заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само описание. Парадигма позволяет писать код, который избавляет от дублирования и выражает цели в ясном, абстрактном подходе:

```swift
// T — Generic тип
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  (a, b) = (b, a)
}

var min = UInt8.min // 0
var max = UInt8.max // 255

swapTwoValues(&min, &max)

var first = "first"
var second = "second"

swapTwoValues(&first, &second)
```

## Что такое Протоколы (protocols)?

[Протокол][protocols] - это набор методов, свойств (проперти) и других требований, которые соответствуют определенной задаче или функциональности. Протокол может быть принят классом, структурой или перечислением для реализации (implementation) этих требований.

```swift
protocol Human {
  var givenName: String { get }
}

struct Person: Human {
  var givenName: String
}

let nick = Person(givenName: "Nick") // nick.givenName это "Nick"
```

> ⚠️ Протокол не содержит реализаций (implementation) свойств и методов. Проперти не содержит данных, а тело метода пустое. Тип, который наследуется от протокола, должен реализовывать все проперти и методы, которые присутствуют в данном протоколе.


## Что такое Tuples (тупл, кортёж)?

Список типов, который разделен запятыми и заключен в круглые скобки.

```swift
let coordinates: (Int, Int) = (2, 3)

var someTuple = (top: 10, bottom: 12)  // someTuple is of type (top: Int, bottom: Int)
someTuple = (top: 4, bottom: 42) // OK: names match
someTuple = (9, 99)              // OK: names are inferred
someTuple = (left: 5, right: 5)  // Error: names don't match
```

## Что такое Optional? (опциональное значение)

Тип данных, который предоставляет обернутое значение или `nil` | `.none`, отсутствие значения. Иными словами, значение может быть или не может. Можно записать как `Optional<Int>`, но предпочтительна более коротка форма `Int?`:

```swift
let shortForm: Int? = Int("42")
let longForm: Optional<Int> = Int("42")

let number: Int? = Optional.some(42)
let noNumber: Int? = Optional.none
print(noNumber == nil) // true
```

Развернуть (получить) значение можно с помощью:
- `Optional Binding` (if let, guard let, switch)

```swift
if let starPath = imagePaths["star"] {
    print("The star image is at '\(starPath)'")
} else {
    print("Couldn't find the star image")
}
```

- `Optional Chaining` используя опциональный постфикс оператор (postfix ?)

```swift
if imagePaths["star"]?.hasSuffix(".png") == true {
    print("The star image is in PNG format")
}
```

- `Nil-Coalescing Operator ??`, предоставляя дефолтное значение

```swift
let defaultImagePath = "/images/default.png"
let heartPath = imagePaths["heart"] ?? defaultImagePath
print(heartPath)
```

- `Unconditional (Force) Unwrapping !`

```swift
let number = Int("42")!
print(number)
```

> ⚠️ Принудительная развертка выражения со значением `nil` приведет к `runtime error`.


## Что такое `Inout` и как его использовать?

По умолчанию все параметры в функциях являются неизменяемыми константами (`immutable let`). Это означает, что ты не можешь изменить значение параметра, т.е.  если ты захочешь изменить значение параметра функции в теле самой функции, то получишь ошибку компиляции. Если возникла такая необходимость, то используй ключевое слово `inout` между параметром и типом данных:

```swift
func reverseName(_ name: inout String) {
  name = "github.com/" + String(name.reversed())
}

var githubUser = "@wmorgue"
print(githubUser) // @wmorgue
reverseName(&githubUser) // github.com/eugromw@
print(githubUser)
```

> ⚠️ Ты не можешь установить дефолтное значение `_ name: inout String = "@wmorgue"`.
Когда передаешь значение в `inout` параметр, то используй амперсанд `&` перед выражением.


## Разница между Self и self?

`Self` указывает на тип протокола, класса, структуры.

`self` указывает на значение, которое оно содержит.


## Что такое lazy? Ленивое свойство хранения и когда оно используется?

Ленивое свойство хранения - свойство, начальное значение которого не вычисляется до первого использования. Индикатор ленивого свойства - ключевое слово `lazy`.

> ⚠️ Всегда объявляйте свойства ленивого хранения как переменные `var`, потому что ее значение может быть не получено до окончания инициализации.


## Что такое defer?

Оператор `defer` — это блок кода, который будет выполнятся в случае выхода из текущей области видимости.
   
```swift
func printStuff() {
  defer { 
    print("Напечатаю 4 и выйду из области видимости")
  }
  print("4")
}

printStuff()
// Выхлоп:
// 4
// Напечатаю 4 и выйду из области видимости
```

`Defer` обычно используется при открытии и закрытии контекста внутри области видимости - например, при доступе к файлам.

## В чём разница между guard и if let?

Оба `guard` и `if let` разворачивают опциональные значения, если они имеются.

Обычно `guard let` используют для раннего выхода из текущей области видимости, поэтому любые значения которые вы разворачиваете, останутся (значения) после проверки в скоупе.
Используя `if let` значение должно использоваться внутри области видимости `if`.


## Преимущества использовать guard statement?

Два основных преимущества использовать `guard`:

1. Избежать пирамиду судьбы (pyramid of doom). Множество вложенных `if let`, уходящих в глубину.
2. Оператор предоставляет ранний выход из функции с помощью `return`.

## Что такое вариативный (variadic) параметр?

Вариативный параметр в функции принимает 0 или несколько значений определенного типа:

```swift
// вариативный параметр может принимать любое кол-во чисел
func redeemVouchers(_ greetings: String, voucherValues: Int...) -> String {
  let voucherText = voucherValues.count > 0 ? " You have redeemed " + "\(voucherValues.reduce(0, +)) €" : ""
  return greetings + voucherText
}
// без вариативного параметра
redeemVouchers("Congratulation!") // "Congratulation!"

// несколько вариативных параметров
redeemVouchers("Congratulation!", voucherValues: 12, 23, 10) // "Congratulation! You have redeemed 45 €"

// один вариативный параметр
redeemVouchers("Congratulation!", voucherValues: 10) // "Congratulation! You have redeemed 10 €"
```

Параметр объявляется с тремя точками `...`. Вызывая функцию, ты можешь не передавать значение второму аргументу или передать несколько.

## Ключевое слово `final` перед `class`?

Добавляя ключевое слово `final` классу/членами класса, мы ограничиваем класс/метод/свойство на переопределение(overridden). Так же мы не можем наследоваться от этого класса:

```swift
final class MyClass {
  final var myVar: String = "You can't override me!"
  final func myMethod() -> Optional<Any> { nil }
  final var myComputedProperty: Int { .zero }
}
```

В опеделенном стечении обстоятельств, `final` может приводить к тому что, класс будет инлайнится на стеке, что теоретически может увеличить производительность (в типичной прикладной iOS разработке этого не заметить никогда, это может быть важно только при написании библиотек).

## В чём разница между static и final?

Статическая переменная/функция доступна всему инстансу класса. `static` используется для проперти/методов, доступ к которым можно получить без создания инстанса класса. С `final` мы не может наследоваться.


## В чём разница между open и public?

`open` позволяет другим модулям использовать класс и наследоваться от него. Члены `open` класса могут быть переопределены (be overridden) другими модулями.

`public` позволяет другим модулям использовать только `public` классы, но не может быть подклассом или переопределен другими модулями.


## В чём разница между операторами `==` и `===`?

Основное различие между двойным `=` и тройным `=` операторами в том, что оператор сравнения `==` сравнивает типы значений, чтобы проверить одинаковы ли они, а  `===` оператор сравнивает ссылочные типы, чтобы проверить, указывают ли ссылки на тот же инстанс.


## Почему мы не может объявить open struct?

Потому что наследование между структурами не возможно. `open` означает, что вы можете переопределить родительский метод/проперти данного класса вне модуля.

## В чём разница между fileprivate, private и public private(set) уровнями доступа?

`fileprivate` доступен в пределах текущего файла. `private` доступен в пределах текущей структуры/класса/enum. `public private(set)` обозначает, что getter публичный, а setter приватный.

## Что такое внутренний (internal) уровень доступа?

Внутренний (internal) уровень доступа позволяет использовать свойства и методы внутри модуля, но не в любом исходном файле за пределами модуля. `internal` установлен по умолчанию и не требует явного объявления:

```swift
// записи равнозначны
var number = 5
internal var number = 5
```

## Объясните разницу между структурой и классом в Swift?

`struct` — value type. `class` — reference type.
При копировании структуры вы получаете 2 уникальных инстанса данных. При копировании класса вы получаете 2 ссылки на один инстанс данных.

## Что такое value/refrence type в Swift?

`Value type` хранит данные в памяти, выделенной на стеке. Когда вы создаете value type, для хранения данных создается одно единственное место(space) в памяти. Существует переменная, в которой хранится стркутура и вы присваеваете ее другой переменной. В таком случае, `value` копируется напрямую, обе переменные работают независимо и они имеют различный адрес в памяти.


`Reference type` хранит в памяти адрес объекта, но не сам объект. Тип указывает адрес переменной, а не сами данные. Присваивая одну переменную другой, данные не копируются. Напротив, создается вторая копия ссылки, которая ссылается на тот же адрес, что и первая.
В отличие от `value`, ссылочный тип не хранит в себе данных. Вместо этого хранится адрес, в котором находятся данные. `Reference type` содержит `pointer`(указатель) на другую область памяти, в которой хранятся данные.

### В чём различие?

Основное различие заключается в том, что `value` type копирует данные, а `refrence` type шарит(shared) одну копию своих данных. Value type является `immutable`(неизменяемым). При объявлении инстанса с `value` type, создается уникальная копия данных. Ссылочный тип является `mutable`(изменяемым) и не создает уникальную копию данных.

В Swift `class` является ссылочным типом. В Objective-C каждый унаследованный элемент от `NSObject` является ссылочным типом. Struct, enum, tuples — value type в Swift. `NSInteger` - это value type в Objective-C.

Распространенные value types:

- struct
- enum
- dictionary
- set
- tuple


Распространенные reference types:

- Class
- Closure
- Function
- Actor

### Почему Apple предпочитает использовать value type по умолчанию?

В языке Swift, value type довольно мощный.

1. Value type по умолчанию thread-safe(потокобезопасны)
2. Инстансы безопасны в multi-threading(многопоточной) среде
3. Может использовать value type не беспокоясь об race conditions(состояние гонки/гонки данных) или deadlocks(взаимная блокировка).

Value type (struct) является предпочтительными. Копировать `value` type будет более безопасным, чем иметь много ссылок на `reference` инстанс. Value type не имеет ссылок в отличие от reference, поэтому никаких утечек памяти не происходит.


> ⚠️ Если вы захватываете struct внутри closure, то по сути захватываете ссылку на инстанс.

Используя `value` type, таких как `struct` или `enum`, вы упрощаете разработку. Можете сконцентрироваться на каком-то участке кода, не беря во внимание общее состояние приложения. Локальные изменения value type не доступны/видны остальной части приложения, в отличие от классов.

### Когда использовать value или reference type?

Следуйте рекомендациям ниже для разработки приложений:

- Используйте структуры там, где это возможно
- Используйте классы для совместимости с Objective-C
- Используйте структуры вместе с протоколами


## Каким простым способом можно реализовать абстракцию в проекте?

Используя протоколы и разделяя модули, например SPM.

##  В чём разница между assign and retain?

`Assigned` элементы получают выделенное место в памяти, а `retain` зависит от жизненного цикла чего-либо выше по иерархии.

## Что такое функции первого класса и поддерживает ли их Swift?

Несмотря на то, что Swift не является чистым функциональным языком программирования, он поддерживает функции первого класса. Это означает, что язык поддерживает передачу функций (closure) в качестве аргументов другим функциям.

## Что такое Copy on Write (COW)?
<!-- Дать отдельный развернутый ответ по COW -->
Copy-on-write - это стратегия используемая в Swift для оптимизации использования памяти. Основная идея COW заключается в том, что когда несколько «вызовов» хотят получить доступ к одинаковому ресурсу, вы можете разместить их указатели на тот же ресурс. Состояние ресурса будет поддерживаться до тех пор, пока «вызывающий» не попытается изменить «копию» ресурса.


## Что такое trailing closure syntax?

Swift позволяют использовать несколько замыканий в качестве параметра функции. Синтаксис `trailing closure` является синтаксическим сахаром для простоты чтения и написания. Trailing closure syntax используется в качестве последнего параметра функции:

```swift
// Without trailing closure syntax
func greeting(title: String, greetingCallBack: () -> ()) {
    print("Hello world, \(title)")
    greetingCallBack()
}
// With trailing closure syntax
func greeting(title: String) {
    print("Hello world, \(title)")
}
```

## Что такое ассоциированный тип (associated type)?

Ассоциированный тип в Swift предоставляет нам placeholder name(обозначение), которое будет использоваться как часть протокола. При наследовании от протокола, будет указан фактический тип. Ассоциированный тип делает протокол обобщенным (generic) предоставляя placeholder.

## Когда использовать Set вместо Array?

`Set` - это неупорядоченная коллекция уникальных значений.
Можно использовать `Set` когда элементы коллекции должны быть `hashable`, уникальными и порядок не важен.

##  В чём разница между as?, as! и as в Swift?

- `as` используется для upcasting.
- `as?` Опциональная форма оператора понижающего приведения. Возвращает опциональное значение типа, к которому вы пытаетесь привести. Вернёт `nil` в случае неудачи.
- `as!` принудительная форма оператора понижающего приведения. Приложение упадет, если каст завершился неудачно.


<!-- Link's section  -->
[type_inference]: https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322
[generics]: https://docs.swift.org/swift-book/LanguageGuide/Generics.html
[protocols]: https://docs.swift.org/swift-book/LanguageGuide/Protocols.html
