## Что такое вывод типов (type inference)?

[Возможность компилятора][type_inference] самому логически вывести тип значения у выражения:

```swift
// константа `myStr` имеет тип данных `String`
let myStr = "Hello, World!"

// явно выводим тип данных
let myStr: String = "Hello, World!"
```

## Для чего используется ключевое слово fallthrough?

С помощью ключевого слова `fallthrough` можно изменить логику функциониро- вания оператора switch и не прерывать его работу после выполнения кода в case- блоке. Данное ключевое слово позволяет перейти к телу последующего case-блока:

```swift
let lvl: Character = "B"

switch lvl {
case "A":
    print("First case is A")
    fallthrough
case "B":
    print("Second case is B")
    fallthrough
case "C":
    print("Last one is C")
default:
    break
}

// Second case is B
// Last one is C
```

## Что такое autoclosure?

`Автозамыкания`(autoclosure) - это замыкания, которые автоматически создаются из переданного выражения.
Например, существует функция, имеющая один или несколько входных параметров, которые при ее вызове передаются как значения, но во внутренней реализации функции используются как самостоятельные замыкания:

```swift
func printName(nextName: @autoclosure () -> String) {
    print(nextName())
}
```

С помощью автозамыканий можно: отложить вычисление переданного значения и передавать значение в виде значения (без фигурных скобок).

## В чем разница между Int и UInt?

Разница между знаковыми и беззнаковыми целочисленными типами в том, что значение знакового типа данных может находиться в интервале от `–2^n–2` до `+2^n–2`, а беззнакового — от `0` до `+2^n–1`, где n — разрядность типа данных (8, 16, 32 или 64).

## Что такое Generics (обобщенное программирование)?

[Парадигма программирования][generics], заключающаяся в таком описании данных и алгоритмов, которое можно применять к различным типам данных, не меняя само описание. Парадигма позволяет писать код, который избавляет от дублирования и выражает цели в ясном, абстрактном подходе:

```swift
// T — Generic тип
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  (a, b) = (b, a)
}

var min = UInt8.min // 0
var max = UInt8.max // 255

swapTwoValues(&min, &max)

var first = "first"
var second = "second"

swapTwoValues(&first, &second)
```

## Что такое Протоколы (protocols)?

[Протокол][protocols] - это набор методов, свойств (проперти) и других требований, которые соответствуют определенной задаче или функциональности. Протокол может быть принят классом, структурой или перечислением для реализации (implementation) этих требований.

```swift
protocol Human {
  var givenName: String { get }
}

struct Person: Human {
  var givenName: String
}

let nick = Person(givenName: "Nick") // nick.givenName это "Nick"
```

> ⚠️ Протокол не содержит реализаций (implementation) свойств и методов. Проперти не содержит данных, а тело метода пустое. Тип, который наследуется от протокола, должен реализовывать все проперти и методы, которые присутствуют в данном протоколе.


## Что такое Tuples (тупл, кортёж)?

Объект, который группирует значения различных типов в пределах одного составного значения.

```swift
let coordinates: (Int, Int) = (2, 3)

var someTuple = (top: 10, bottom: 12)  // someTuple is of type (top: Int, bottom: Int)
someTuple = (top: 4, bottom: 42) // OK: names match
someTuple = (9, 99)              // OK: names are inferred
someTuple = (left: 5, right: 5)  // Error: names don't match
```

> Типом данных тупла является фиксированная упорядоченная последовательность имен типов данных элементов тупла.


## Расскажите о коллекциях (collection)?

`Collection` — это протокол, последовательность (`Sequence`), в которой можно обращаться к отдельному элементу напрямую. Не может быть бесконечной (в отличие от `Sequence`).

## Что такое Optional? (опциональное значение)

Перечисление `Optional<Wrapped>` c двумя кейсами: `.some(Wrapped)` и `.none`:

```swift
@frozen
public enum Optional<Wrapped>: ExpressibleByNilLiteral {
  case none
  case some(Wrapped)
}
```

Тип данных, который предоставляет обернутое значение или `nil` | `.none`, отсутствие значения. Иными словами, значение может быть или не может. Можно записать как `Optional<Int>`, но предпочтительна более коротка форма `Int?`:

```swift
let shortForm: Int? = Int("42")
let longForm: Optional<Int> = Int("42")

let number: Int? = Optional.some(42)
let noNumber: Int? = Optional.none
print(noNumber == nil) // true
```

Развернуть (получить) значение можно с помощью:
- `Optional Binding` (if let, guard let, switch)

```swift
if let starPath = imagePaths["star"] {
    print("The star image is at '\(starPath)'")
} else {
    print("Couldn't find the star image")
}
```

- `Optional Chaining` используя опциональный постфикс оператор (postfix ?)

```swift
if imagePaths["star"]?.hasSuffix(".png") == true {
    print("The star image is in PNG format")
}
```

- `Nil-Coalescing Operator ??`, предоставляя дефолтное значение

```swift
let defaultImagePath = "/images/default.png"
let heartPath = imagePaths["heart"] ?? defaultImagePath
print(heartPath)
```

- `Unconditional (Force) Unwrapping !`

```swift
let number = Int("42")!
// или c помощью проперти let number = Int("42").unsafelyUnwrapped
print(number)
```

> ⚠️ Принудительная развертка выражения со значением `nil` приведет к `runtime error`.


## Что такое `Inout` и как его использовать?

По умолчанию все параметры в функциях являются неизменяемыми константами (`immutable let`). Это означает, что ты не можешь изменить значение параметра, т.е.  если ты захочешь изменить значение параметра функции в теле самой функции, то получишь ошибку компиляции. Если возникла такая необходимость, то используй ключевое слово `inout` между параметром и типом данных:

```swift
func reverseName(_ name: inout String) {
  name = "github.com/" + String(name.reversed())
}

var githubUser = "@wmorgue"
print(githubUser) // @wmorgue
reverseName(&githubUser) // github.com/eugromw@
print(githubUser)
```

> ⚠️ Ты не можешь установить дефолтное значение `_ name: inout String = "@wmorgue"`.
Когда передаешь значение в `inout` параметр, то используй амперсанд `&` перед выражением.


## Разница между Self и self?

`Self` указывает на тип протокола, класса, структуры.

`self` указывает на значение, которое оно содержит.


## Что такое lazy? Ленивое свойство хранения и когда оно используется?

Ленивое свойство хранения - свойство, начальное значение которого не вычисляется до первого использования. Индикатор ленивого свойства - ключевое слово `lazy`.

> ⚠️ Всегда объявляйте свойства ленивого хранения как переменные `var`, потому что ее значение может быть не получено до окончания инициализации.


## Что такое defer?

Оператор `defer` — это блок кода, который будет выполнятся в случае выхода из текущей области видимости.
   
```swift
func printStuff() {
  defer { 
    print("Напечатаю 4 и выйду из области видимости")
  }
  print("4")
}

printStuff()
// Выхлоп:
// 4
// Напечатаю 4 и выйду из области видимости
```

`Defer` обычно используется при открытии и закрытии контекста внутри области видимости - например, при доступе к файлам.

## В чём разница между guard и if let?

Оба `guard` и `if let` разворачивают опциональные значения, если они имеются.

Обычно `guard let` используют для раннего выхода из текущей области видимости, поэтому любые значения которые вы разворачиваете, останутся (значения) после проверки в скоупе.
Используя `if let` значение должно использоваться внутри области видимости `if`.


## Преимущества использовать guard statement?

Два основных преимущества использовать `guard`:

1. Избежать пирамиду судьбы (pyramid of doom). Множество вложенных `if let`, уходящих в глубину.
2. Оператор предоставляет ранний выход из функции с помощью `return`.

## Что такое вариативный (variadic) параметр?

Вариативный параметр в функции принимает 0 или несколько значений определенного типа:

```swift
// вариативный параметр может принимать любое кол-во чисел
func redeemVouchers(_ greetings: String, voucherValues: Int...) -> String {
  let voucherText = voucherValues.count > 0 ? " You have redeemed " + "\(voucherValues.reduce(0, +)) €" : ""
  return greetings + voucherText
}
// без вариативного параметра
redeemVouchers("Congratulation!") // "Congratulation!"

// несколько вариативных параметров
redeemVouchers("Congratulation!", voucherValues: 12, 23, 10) // "Congratulation! You have redeemed 45 €"

// один вариативный параметр
redeemVouchers("Congratulation!", voucherValues: 10) // "Congratulation! You have redeemed 10 €"
```

Параметр объявляется с тремя точками `...`. Вызывая функцию, ты можешь не передавать значение второму аргументу или передать несколько.

## Ключевое слово `final` перед `class`?

Добавляя ключевое слово `final` классу/членами класса, мы ограничиваем класс/метод/свойство на переопределение(overridden). Так же мы не можем наследоваться от этого класса:

```swift
final class MyClass {
  final var myVar: String = "You can't override me!"
  final func myMethod() -> Optional<Any> { nil }
  final var myComputedProperty: Int { .zero }
}
```

В определенном стечении обстоятельств, `final` может приводить к тому что, класс будет инлайнится на стеке, что теоретически может увеличить производительность (в типичной прикладной iOS разработке этого не заметить никогда, это может быть важно только при написании библиотек).

## Что происходит с классом при компиляции?

1. Разбирается в синтаксическом дереве. Отрабатывает алгоритм SIL-level aggregate layout. Строится vtable. Строится  value witness table(не для всех). Дополнительная кодогенерация. Проходит процедуру манглинга. Разбивается на SIL блоки, которые содержат SIL инструкции. Проходит процедуру проверки достижимости, мелкие оптимизации.
2. Далее идут высокоуровневые контекстно-зависимые оптимизации, оптимизация ARC.
3. Далее все оптимизированные SIL блоки + SIL инструкции конвертируются в LLVM IR инструкции. Там происходят уже платформозависимые оптимизации, где после LLVM превращает эти инструкции в машинный код. 


## В чём разница между static и final?

Статическая переменная/функция доступна всему инстансу класса. `static` используется для проперти/методов, доступ к которым можно получить без создания инстанса класса. С `final` мы не может наследоваться.


## В чём разница между open и public?

`open` позволяет другим модулям использовать класс и наследоваться от него. Члены `open` класса могут быть переопределены (be overridden) другими модулями.

`public` позволяет другим модулям использовать только `public` классы, но не может быть подклассом или переопределен другими модулями.


## В чём разница между операторами `==` и `===`?

Основное различие между двойным `=` и тройным `=` операторами в том, что оператор сравнения `==` сравнивает типы значений, чтобы проверить одинаковы ли они, а  `===` оператор сравнивает ссылочные типы, чтобы проверить, указывают ли ссылки на тот же инстанс.


## Почему мы не может объявить open struct?

Потому что наследование между структурами не возможно. `open` означает, что вы можете переопределить родительский метод/проперти данного класса вне модуля.

## В чём разница между fileprivate, private и public private(set) уровнями доступа?

`fileprivate` доступен в пределах текущего файла. `private` доступен в пределах текущей типа, в котором был объявлен. `public private(set)` обозначает, что getter публичный, а setter приватный.

## Что такое внутренний (internal) уровень доступа?

Внутренний (internal) уровень доступа позволяет использовать свойства и методы внутри модуля, но не в любом исходном файле за пределами модуля. `internal` установлен по умолчанию и не требует явного объявления:

```swift
// записи равнозначны
var number = 5
internal var number = 5
```

## Объясните разницу между структурой и классом в Swift?

`struct` — value type. Копируются. Изменение одного инстанса не влияет на второй.

`class` — reference type. Передаются по ссылке. Изменение одного инстанса влечет за собой изменение второго.

## Что такое value/refrence type в Swift?

`Value type` хранит данные в памяти, выделенной на стеке. Когда вы создаете value type, для хранения данных создается одно единственное место(space) в памяти. Существует переменная, в которой хранится структура и вы присваиваете ее другой переменной. В таком случае, `value` копируется напрямую, обе переменные работают независимо и они имеют различный адрес в памяти.


`Reference type` хранит в памяти адрес объекта, но не сам объект. Тип указывает адрес переменной, а не сами данные. Присваивая одну переменную другой, данные не копируются. Напротив, создается вторая копия ссылки, которая ссылается на тот же адрес, что и первая.
В отличие от `value`, ссылочный тип не хранит в себе данных. Вместо этого хранится адрес, в котором находятся данные. `Reference type` содержит `pointer`(указатель) на другую область памяти, в которой хранятся данные.

### В чём различие?

Основное различие заключается в том, что `value` type копирует данные, а `refrence` type шарит(shared) одну копию своих данных. Value type является `immutable`(неизменяемым). При объявлении инстанса с `value` type, создается уникальная копия данных. Ссылочный тип является `mutable`(изменяемым) и не создает уникальную копию данных.

В Swift `class` является ссылочным типом. В Objective-C каждый унаследованный элемент от `NSObject` является ссылочным типом. Struct, enum, tuples — value type в Swift. `NSInteger` - это value type в Objective-C.

Распространенные value types:

- struct
- enum
- dictionary
- set
- tuple


Распространенные reference types:

- Class
- Closure
- Function
- Actor

### Почему Apple предпочитает использовать value type по умолчанию?

В языке Swift, value type довольно мощный.

1. Value type по умолчанию thread-safe(потокобезопасны)
2. Инстансы безопасны в multi-threading(многопоточной) среде
3. Может использовать value type не беспокоясь об race conditions(состояние гонки/гонки данных) или deadlocks(взаимная блокировка).

Value type (struct) является предпочтительными. Копировать `value` type будет более безопасным, чем иметь много ссылок на `reference` инстанс. Value type не имеет ссылок в отличие от reference, поэтому никаких утечек памяти не происходит.


> ⚠️ Если вы захватываете struct внутри closure, то по сути захватываете ссылку на инстанс.

Используя `value` type, таких как `struct` или `enum`, вы упрощаете разработку. Можете сконцентрироваться на каком-то участке кода, не беря во внимание общее состояние приложения. Локальные изменения value type не доступны/видны остальной части приложения, в отличие от классов.

### Когда использовать value или reference type?

Следуйте рекомендациям ниже для разработки приложений:

- Используйте структуры там, где это возможно
- Используйте классы для совместимости с Objective-C
- Используйте структуры вместе с протоколами


## Может ли структура хранить данные в хипе?

Хип и стек - это про то, где лежат данные, `value` и `ref` type - это про то, как они передаются.
Действительно, структура может храниться в хипе. Не зависит от того есть у нее поля типа класса или нет.

> ⚠️ структура никогда не будет являться `reference` типом
> счетчик ссылок никак не связан с хипом или стеком, счетчик ссылок — это способ считать ссылки когда у тебя их много. Можно держать структуру в хипе и держать на нее всегда ровно одну ссылку, тем самым обходиться без счетчика.

Важно уточнить, что структура никогда не будет передаваться по ссылке так же как и класс.
Closure имеет ссылку на структуру, но не удерживает ее, то есть это больше похоже на weak ссылку, хотя технически это другой механизм.

## Каким простым способом можно реализовать абстракцию в проекте?

Используя протоколы и разделяя модули, например SPM.

##  В чём разница между assign and retain?

`Assigned` элементы получают выделенное место в памяти, а `retain` зависит от жизненного цикла чего-либо выше по иерархии.

## Что такое функции первого класса и поддерживает ли их Swift?

Несмотря на то, что Swift не является чистым функциональным языком программирования, он поддерживает функции первого класса. Это означает, что язык поддерживает передачу функций (closure) в качестве аргументов другим функциям.

## Что такое Copy on Write (COW)?

Основная идея COW заключается в том, что когда несколько «вызовов» хотят получить доступ к одинаковому ресурсу, вы можете разместить их указатели на тот же ресурс. Состояние ресурса будет поддерживаться до тех пор, пока «вызывающий» не попытается изменить «копию» ресурса.

`Copy-on-write` - это способ оптимизации, который идёт из реализации некоторых типов в стандартной библиотеки. Без типов из стандартной библиотеки нет явного способа сделать свой тип COW. Всякая инструкция COW начинается как `ref_element_addr` и заканчивается `end_cow_mutation`.


> ⚠️ На текущий момент (Swift 5.7), COW реализован только для `std`, а не для языка Swift. 

## Почему порядок ключей будет сохраняться между мутациями в словаре?

Dictionary — неупорядоченная коллекция. Причина повторяющегося «иногда или при определённых обстоятельствах» порядка ключей заключается в следующем:

Словарь в Swift, как и в любом другом языке, целиком и полностью основывается на таком понятии как `HashTable`. В свою очередь HashTable представляет из себя такую структуру, в которой "ключи"(на самом деле не ключ, а некая сущность Word, которая получается из хеша ключа + seed + адрес памяти буфера) хранятся в последовательном участке памяти. То есть очень похожее на то, что делает обычный массив, но со своей логикой вставки и удаления:

```swift
internal struct _HashTable {
  internal typealias Word = _UnsafeBitset.Word
  internal var words: UnsafeMutablePointer<Word>
  internal let bucketMask: Int
  //...
}
```

Отсюда, словарь гарантирует, что порядок ключей будет сохраняться только между мутациями.

> Нет мутаций - порядок сохранился, произошла мутация, порядок изменился.

Но это снова не даёт ответа на вопрос, почему всё таки при каждом проходе по ключам, словарь выдаёт их в разном порядке. Ведь словарь гарантирует порядок ключей между мутациями, которых мы и не делаем. Всё дело в таком понятии, как `DETERMINISTIC HASHING`. Детерминированный хеш означает, что в рамках одного и того же процесса, хеш от элемента всегда будет одним и тем же. Я напомню, что Словарь не использует просто хеш от  ключа, а использует:

> хеш от ключа в словаре = хеш от ключа + RANDOM_SEED_PER_INSTANCE + адрес памяти буфера.

Поэтому, когда ты каждый раз пишешь:

```swift
for (k, v) in dictionary {
 // ...
}
```

создаётся итератор словаря, который в свою очередь содержит в себе итератор `_HashTable`:

```swift
internal struct _HashTable.Iterator: IteratorProtocol {
  let hashTable: _HashTable
  // ...
}
```

то есть каждый раз создаётся новый `_HashTable`, в котором элементы стоят на том же месте (это вообще те же самые элементы), где и стояли, но меняется  seed и иногда и адрес памяти буфера.

Отсюда, несмотря на то, что элементы стоят в том же порядке, что и стояли до этого, порядок их сменился ввиду того что сменились seed и возможно адрес памяти буфера.

Детерминированный хеш хорошо иметь во время тестов, возможно где-то ещё, но в обычном смысле, такое поведение ничему хорошему не способствует.
Если проводите тесты и вам нужен детерминированный хеш, то можно задать переменную окружения `SWIFT_DETERMINISTIC_HASHING=1`

## Расскажите о Swift Intermediate Language(SIL)?

Swift Intermediate Language — это приватное для компилятора Swift промежуточное представление, которое находится на более низком уровне абстракции, чем AST, но всё ещё выше промежуточного представления LLVM. Для своего представления SIL использует нотацию SSA.

## Что такое trailing closure syntax?

Swift позволяют использовать несколько замыканий в качестве параметра функции. Синтаксис `trailing closure` является синтаксическим сахаром для простоты чтения и написания. Trailing closure syntax используется в качестве последнего параметра функции:

```swift
// Without trailing closure syntax
func greeting(title: String, greetingCallBack: () -> ()) {
    print("Hello world, \(title)")
    greetingCallBack()
}
// With trailing closure syntax
func greeting(title: String) {
    print("Hello world, \(title)")
}
```

## Что такое ассоциированный тип (associated type)?

Ассоциированный тип в Swift предоставляет нам placeholder name(обозначение), которое будет использоваться как часть протокола. При наследовании от протокола, будет указан фактический тип. Ассоциированный тип делает протокол обобщенным (generic) предоставляя placeholder.

## Когда использовать Set вместо Array?

`Set` - это неупорядоченная коллекция уникальных значений.
Можно использовать `Set` когда элементы коллекции должны быть `hashable`, уникальными и порядок не важен.

##  В чём разница между as?, as! и as в Swift?

- `as` используется для upcasting.
- `as?` Опциональная форма оператора понижающего приведения. Возвращает опциональное значение типа, к которому вы пытаетесь привести. Вернёт `nil` в случае неудачи.
- `as!` принудительная форма оператора понижающего приведения. Приложение упадет, если каст завершился неудачно.


<!-- Link's section  -->
[type_inference]: https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID322
[generics]: https://docs.swift.org/swift-book/LanguageGuide/Generics.html
[protocols]: https://docs.swift.org/swift-book/LanguageGuide/Protocols.html
