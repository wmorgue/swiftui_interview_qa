# `Sendable` and `@Sendable` closures

## Введение

Основной целью `Swift Concurrency` является «обеспечить механизм для изолированного состояния в конкурентных программах для устранения data races».
Такой механим будет большим прогрессом для многих языков программирования — большинство из ЯП предоставляют некую обстракцию для конкурентного программирования, что влечет за собой классические ошибки: race conditions, deadlocks и другие.

Данное введение описывает подход для решения одной из проблем в области конкрурентного программирования: «Как проверить типы данных переданные между structured concurrency constructs и сообщениями акторов?».
Это теория, которая предоставляет механизм для типов данных, который обеспечивает хорошую и безопасную работу вместе.

Ниже описана реализация маркерного протокола `Sendable` и атрибута `@Sendable`, который может применяться к функциям.

## Мотивация

Каждый инстанс актора и задача(`task`) в программе представляют собой «остров однопоточности», что делает их естественной точкой синхронизации, хранящей сумку с изменяемым состоянием.
Острова выполняют вычисления параллельно с другими задачами, но мы хотим, чтобы подавляющее большинство кода в такой системе было свободным от синхронизации - основываясь на логической независимости актора и используя его «почтовый ящик» в качестве точки синхронизации для своих данных.

Вопрос: «Когда и как разрешать передавать данные между concurrency доменами?».
Такие передачи/перемещения происходят в вызовах метода актора или `task`.
`Swift Concurrency` направлены на создание безопасной и мощной модели программирования. Мы хотим добиться трех вещей:

1. Получать статическую ошибку компилятора при передаче данных через `concurrency` домены, которые могут иметь незащищенное изменяемое состояние.
2. Позволить реализовывать сложные библиотеки, которые можно безопасно использовать.
3. Плавная и постепенная миграция на новую модель `Swift Concurrency`.

И прежде, чем перейти к решению, рассмотрим общие случаи и проблемы. Это поможет рассуждать о дизайне проектирования.

### Swift + Value Semantics

Первым типом поддерживаемых данных, будут простые значения, например структура `Int`.
`Int` можно легко передавать через `concurrency` домены, поскольку структура не содержит указателей (`pointers`).

Swift уделяет большое внимание типам данных с `value` семантикой, которые можно безопасно передавать через границы `concurrency`.
Например, коллецию `Dictionary<Int, String>` можно передавать напрямую через домены. В контексте `Copy on Write` оптимизации, это означает что такие коллекции могут передаваться **без создания копии**, поэтому `concurrency` модель очень эффективна на практике.

Но есть ограничения. Коллекции из стандартной библиотеки (`std`) могут передаваться не безопасно, если они содержат ссылки на классы, замыкания захватывающие изменяемое состояние и другие не `value` типы данных.
Поэтому нам нужен способ, с помощью которого мы сможем различать, какие типы данных можно передать безопасно, а какие нет.

### Value Semantic Composition

Structs, enums и tuples являются основным способом композиции в Swift.
Эти типы данных безопасны для передачи через concurrency домены — при условии, что содержащиеся в них данные сами по себе безопасны для передачи.

### Функции высшего порядка

В свифте и других языках с поддержкой ФП, принято использовать функции высшего порядка (передача функции в другую функцию).
Функции высшего порядка являются ссылочным типом, но большинство из можно можно безопасно передавать через concurrency домены.
Рассмотрим на примере с актором:

```swift
actor MyContactList {
  func filteredElements(_ fn: (ContactElement) -> Bool) async -> [ContactElement] { … }
}
```

Далее можно использовать так:

```swift
// Замыкание без захвата ok!
list = await contactList.filteredElements { $0.firstName != "Max" }

// Захватывать 'searchName' строку по значению ok, потому что строки
// передаются по concurrency домену.
list = await contactList.filteredElements {
  [searchName] in $0.firstName == searchName
}
```

Мы считаем, что важно обеспечить возможность передачи функций через домены, но так же мы не должны разрешать захват локального состояния по ссылке в этих функциях, как и захват небезопасных выражений по значению.
В обоих случаях это создаст проблемы с безопасностью памяти.

### Неизменяемые классы

Одним из распространенных и эффективных шаблонов проектирования в concurrent программировании является создание неизменяемых структур данных - совершенно безопасно передавать ссылку на класс через домены, если состояние внутри никогда не изменяется.
Этот шаблон проектирования чрезвычайно эффективен (не требуется синхронизация за пределами `ARC`), может быть использован для построения продвинутых структур данных и широко изучается сообществом чисто функциональных языков.

### Internally Synchronized Reference Types (Локальная синхронизация ссылочного типа)

Стандартным шаблоном проектирования в concurrency системах является создание классом «потокобезопасного» API: он защищает свое состояние с помощью явной синхронизации (мьютексы, atomics и т.д.).
Поскольку публичный API класса безопасен для использования из нескольких доменов, ссылка на класс может быть безопасно передана напрямую.

Примером могут служить ссылки на сами экземпляры акторов: безопасно передавать указатель между доменами, поскольку изменяемое состояние внутри актора неявно защищено его «почтовым ящиком».

### Deep Copying Classes

Одним из безопасных способов передачи ссылочного типа является создание «глубокой копии данных», гарантируя что исходный и конечный домен имеют собственнуб копию изменяемого состояния.
Может быть затратным для большого кол-ва данных, но широко используется в некоторых фреймворках Objective-C.

### Заключение введения

Это всего лишь выборка паттернов, но как мы видим, существует широкий спектр различных паттернов `concurrent` проектирования, которые широко используются.
Дизайн Swift вокруг типов значений и использования структур - это очень мощная и полезная отправная точка, но нам нужно уметь рассуждать и о сложных случаях - как для сообществ, которые хотят иметь возможность создавать высокопроизводительные API для определенной области, так и потому что нам нужно работать с устаревшим кодом, который не будет переписан за одну ночь.
