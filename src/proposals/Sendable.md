# `Sendable` and `@Sendable` closures

## Введение

Основной целью `Swift Concurrency` является «обеспечить механизм для изолированного состояния в конкурентных программах для устранения data races».
Такой механим будет большим прогрессом для многих языков программирования — большинство из ЯП предоставляют некую обстракцию для конкурентного программирования, что влечет за собой классические ошибки: race conditions, deadlocks и другие.

Данное введение описывает подход для решения одной из проблем в области конкрурентного программирования: «Как проверить типы данных переданные между structured concurrency constructs и сообщениями акторов?».
Это теория, которая предоставляет механизм для типов данных, который обеспечивает хорошую и безопасную работу вместе.

Ниже описана реализация маркерного протокола `Sendable` и атрибута `@Sendable`, который может применяться к функциям.

## Мотивация

Каждый инстанс актора и задача(`task`) в программе представляют собой «остров однопоточности», что делает их естественной точкой синхронизации, хранящей сумку с изменяемым состоянием.
Острова выполняют вычисления параллельно с другими задачами, но мы хотим, чтобы подавляющее большинство кода в такой системе было свободным от синхронизации - основываясь на логической независимости актора и используя его «почтовый ящик» в качестве точки синхронизации для своих данных.

Вопрос: «Когда и как разрешать передавать данные между concurrency доменами?».
Такие передачи/перемещения происходят в вызовах метода актора или `task`.
`Swift Concurrency` направлены на создание безопасной и мощной модели программирования. Мы хотим добиться трех вещей:

1. Получать статическую ошибку компилятора при передаче данных через `concurrency` домены, которые могут иметь незащищенное изменяемое состояние.
2. Позволить реализовывать сложные библиотеки, которые можно безопасно использовать.
3. Плавная и постепенная миграция на новую модель `Swift Concurrency`.

И прежде, чем перейти к решению, рассмотрим общие случаи и проблемы. Это поможет рассуждать о дизайне проектирования.

### Swift + Value Semantics

Первым типом поддерживаемых данных, будут простые значения, например структура `Int`.
`Int` можно легко передавать через `concurrency` домены, поскольку структура не содержит указателей (`pointers`).

Swift уделяет большое внимание типам данных с `value` семантикой, которые можно безопасно передавать через границы `concurrency`.
Например, коллецию `Dictionary<Int, String>` можно передавать напрямую через домены. В контексте `Copy on Write` оптимизации, это означает что такие коллекции могут передаваться **без создания копии**, поэтому `concurrency` модель очень эффективна на практике.

Но есть ограничения. Коллекции из стандартной библиотеки (`std`) могут передаваться не безопасно, если они содержат ссылки на классы, замыкания захватывающие изменяемое состояние и другие не `value` типы данных.
Поэтому нам нужен способ, с помощью которого мы сможем различать, какие типы данных можно передать безопасно, а какие нет.

### Value Semantic Composition

Structs, enums и tuples являются основным способом композиции в Swift.
Эти типы данных безопасны для передачи через concurrency домены — при условии, что содержащиеся в них данные сами по себе безопасны для передачи.

### Функции высшего порядка

В свифте и других языках с поддержкой ФП, принято использовать функции высшего порядка (передача функции в другую функцию).
Функции высшего порядка являются ссылочным типом, но большинство из можно можно безопасно передавать через concurrency домены.
Рассмотрим на примере с актором:

```swift
actor MyContactList {
  func filteredElements(_ fn: (ContactElement) -> Bool) async -> [ContactElement] { … }
}
```

Далее можно использовать так:

```swift
// Замыкание без захвата ok!
list = await contactList.filteredElements { $0.firstName != "Max" }

// Захватывать 'searchName' строку по значению ok, потому что строки
// передаются по concurrency домену.
list = await contactList.filteredElements {
  [searchName] in $0.firstName == searchName
}
```

Мы считаем, что важно обеспечить возможность передачи функций через домены, но так же мы не должны разрешать захват локального состояния по ссылке в этих функциях, как и захват небезопасных выражений по значению.
В обоих случаях это создаст проблемы с безопасностью памяти.

### Неизменяемые классы

Одним из распространенных и эффективных шаблонов проектирования в concurrent программировании является создание неизменяемых структур данных - совершенно безопасно передавать ссылку на класс через домены, если состояние внутри никогда не изменяется.
Этот шаблон проектирования чрезвычайно эффективен (не требуется синхронизация за пределами `ARC`), может быть использован для построения продвинутых структур данных и широко изучается сообществом чисто функциональных языков.

### Internally Synchronized Reference Types (Локальная синхронизация ссылочного типа)

Стандартным шаблоном проектирования в concurrency системах является создание классом «потокобезопасного» API: он защищает свое состояние с помощью явной синхронизации (мьютексы, atomics и т.д.).
Поскольку публичный API класса безопасен для использования из нескольких доменов, ссылка на класс может быть безопасно передана напрямую.

Примером могут служить ссылки на сами экземпляры акторов: безопасно передавать указатель между доменами, поскольку изменяемое состояние внутри актора неявно защищено его «почтовым ящиком».

### Deep Copying Classes

Одним из безопасных способов передачи ссылочного типа является создание «глубокой копии данных», гарантируя что исходный и конечный домен имеют собственнуб копию изменяемого состояния.
Может быть затратным для большого кол-ва данных, но широко используется в некоторых фреймворках Objective-C.

### Заключение введения

Это всего лишь выборка паттернов, но как мы видим, существует широкий спектр различных паттернов `concurrent` проектирования, которые широко используются.
Дизайн Swift вокруг типов значений и использования структур - это очень мощная и полезная отправная точка, но нам нужно уметь рассуждать и о сложных случаях - как для сообществ, которые хотят иметь возможность создавать высокопроизводительные API для определенной области, так и потому что нам нужно работать с устаревшим кодом, который не будет переписан за одну ночь.


## Решение и детали дизайна

Высокоуровневый дизайн решения знакомит вас с маркерным протоколом `Sendable`, адоптацией стандартной библиотеки с помощью `Sendable` и новый атрибутом для функций `@Sendable`.

## Marker Protocols (протокол маркер)

Наконец-то вы познакомитесь с концептом протокола «маркера», который сообщает, что протокол имеет некоторые семантические свойства, которые не влияют на runtime.
Протокол маркер имеет следующие ограничения:

1. Не имеет требований (`requirements`).
2. Не может подписываться на «не маркерные» протоколы.
3. Не может назван в качестве типа, проверки `is` или каста (e.g., x `as?` Sendable is an error).
4. Не может использоваться вместе с дженериками в качестве соотвествия не маркерному протоколу.

Мы считаем, что это полезная функция, но на данный момент она должна быть внутренней фичей компилятора.
Поэтому ниже мы используем эту концепцию с синтаксисом атрибута `@_marker`.

## `Sendable` Protocol

Сосредоточимся на протоколе маркере объявленным в стандартной библиотеке (`std`), который имеет специальные правила проверки соответствия:

```swift
@_marker
protocol Sendable {}
```

Хорошей идеей для типов данных является соответствие протоколу Sendable, если они разработаны так, что все их публичные API безопасны для использования в разных доменах.
<!-- It is a good idea for types to conform to the Sendable protocol when they are designed so all of their public API is safe to use across concurrency domains. This is true for example, when there are no public mutators, if public mutators are implemented with COW, or if they are implemented with internal locking or some other mechanism. Types may of course have internal implementation details based on local mutation if they have locking or COW as part of their public API. -->
Компилятор отклоняет любые попытки передачи данных через домены, когда аргумент или результат отправки сообщения актором не подписаны на `Sendable.`

```swift
actor SomeActor {
  // async функция объявлена внутри актора, поэтому
  // ошибок нет.
  func doThing(string: NSMutableString) async {...}
}

// ... но нельзя вызвать из другого места, не защищеным
// почтовым ящиком актора:
func f(a: SomeActor, myString: NSMutableString) async {
  // ошибка: 'NSMutableString' не может быть передан между акторами;
  //        не подписан на 'Sendable'
  await a.doThing(string: myString)
}
```

Протокол `Sendable` «моделирует» типы, которые можно безопасно передавать между concurrency доменами, с помощью копирования значения.
Сюда входят типы с `value` значения, ссылки на неизменяемые ссылочные типы, внутренние синхронизированные ссылочные типы, замыкания `@Sendable` и другие __будущие__ расширения системы типов для уникального владения (`ownership`) и т.д.

> ⚠️ Неправильное соответствие этому протоколу может внести ошибки в программу (так же, как неправильная реализация `Hashable` может сломать инварианты), поэтому компилятор делает соответствие.

#### Tuple + `Sendable`

В свифте захардкодили `tuple` на определенные протоколы и тип данных должен реализовывать расширение с подписью на `Senddable`.

#### Metatype conformance to Sendable

Метатипы, такие как `Int.Type`,  `Int.self`, всегда подписаны на `Sendable`, поскольку они неизменемы (`immutable`).


#### `Sendable` conformance checking for `structs` and `enums`

Типы данных, подписанные на `Sendable` очень распространены в Swift и их агрегаты безопасны для передачи между доменами.
Компилятор позволяет подписывать структур и классов на `Sendable`, которые являются композициями других типов `Sendable`:

```swift
struct MyPerson : Sendable { var name: String, age: Int }
struct MyNSPerson { var name: NSMutableString, age: Int }

actor SomeActor {
  // Structs and tuples are ok to send and receive!
  public func doThing(x: MyPerson, y: (Int, Float)) async {..}

  // error if called across actor boundaries: MyNSPerson doesn't conform to Sendable!
  public func doThing(x: MyNSPerson) async {..}
}
```

Компилятор сообщит об ошибке, если в структуре или `enum` проперти не соотвествуют `Sendable` или сам тип данных, в том числе дженерик:

```swift
// ошибка: структура MyNSPerson не может быть подписана на Sendable из-за проперти NSMutableString.
// заметка: добавьте '@unchecked' атрибут если вы знаете что здесь происходит.
struct MyNSPerson : Sendable {
  var name: NSMutableString
  var age: Int
}

// ошибка: структура MyPair не может быть подписана на Sendable из-за дженерика 'T', который сам не подписан на Sendable
// заметка: смотрите ниже как подписать джененик
struct MyPair<T> : Sendable {
  var a, b: T
}

// используйте расширение, чтобы задать протокол явно
struct MyCorrectPair<T> {
  var a, b: T
}

extension MyCorrectPair: Sendable where T: Sendable { }
```

Выше компилятор сообщил о том, что можно добавить атрибут `@unchecked Sendable`, чтобы перезаписать поведение и убрать ошибку.
Данный атрибут означает, что данные можно безопасно передавать между доменами, но разработчику требуется убедиться в безопасности такой передачи.

Структура или `enum` можно подписать на `Sendable` только в том же файле, где был объявлен тип данных:
Это гарантия, что хранящиеся проперти структуры и `associated values` перечесления будут доступны для проверки на соотвествие `Sendable`:

```swift
// MySneakyNSPerson.swift
struct MySneakyNSPerson {
  private var name: NSMutableString
  public var age: Int
}

// NotAMySneakyNSPerson.swift
// данное расширение объвлено в другом файле или модуле...
// ошибка: нельзя подписаться на Sendable вне исходного
// объявления MySneakyNSPerson
extension MySneakyNSPerson: Sendable { }
```

Без такой проверки, другой исходный файл или модуль, который не может получить доступ к приватной проперти `name`, думал что структура подписана на `Sendable`.
Однако, мы может добавить не безопасный атрибут `@unckecked` для отключения проверки:

```swift
// в другом файле или модуле...
// okay: unchecked позволяет подписать структуру на Sendable из другого файла/модуля
extension MySneakyNSPerson: @unchecked Sendable { }
```

#### Неявная подпись struct/enum на `Sendable`

Многие структуры и перечисления подписаны на `Sendable` и необходимость всегда писать `: Sendable` для каждого такого типа может утомить.
Для непубличных структур и перечислений, которые также не являются `@usableFromInline` и для `frozen` публичных структур и перечислений соответствие Sendable неявно обеспечивается при проверке(описанной в предыдущем разделе):

```swift
struct MyPerson2 { // Структура неявно подписана на Sendable!
  var name: String, age: Int
}

class NotConcurrent { } // Не подписан на Sendable

struct MyPerson3 { // Не подписан на Sendable, потому что nc не является Sendable типом
  var nc: NotConcurrent
}
```

Public non-frozen структуры и `enums` не подписаны неявно на `Sendable`, потому что это вызовет проблемы при проектировании API.
Добавив не `Sendable` в такой тип данных можно сломать логику.

> ⚠️ `Sendable` не влияет на размер бинарного файла, в отличии от других протоколов.

#### `Sendable` conformance checking for classes

Каждый объявленный класс можно подписать на `Sendable` с атрибутом `@unchecked`, позволяя передавать из между акторами без семантической проверки.
Это подходит для классов, которые используют контроль доступа и внутреннюю синхронизацию для обеспечения безопасности памяти - обычно эти механизмы не могут быть проверены компилятором.

Класс можно подписать на `Sendable` и проверка безопасности памяти будет работать только в ситуации, когда класс имеет ключевое слово `final` и содержит только не изменяемые проперти соответствующие `Sendable`:

```swift
final class MyClass : Sendable {
  let state: String
}
```

Такие классы не могут наследоваться от классов, отличных от `NSObject` (для совместимости с `Objective-C`).
Классы с `Sendable` имеют то же ограничение, что и structs и enums, которые требуют, чтобы подпись на `Sendable` происходила в том же исходном файле.

Такое поведение позволяет безопасно создавать и передавать неизменяемые состояния между акторам. На данный момент нельзя неявно подписываться на `Sendable`.
Такое ограничение сделано специально.

#### В акторах

Акторы содержат свою внутреннюю синхронизацию, поэтому неявно подписаны на `Sendable`. [Ознакомьтесь с введением в акторы](Actors.md).

#### Key path literals

`Key paths` сам по себе подписан на протокол `Sendable`. Чтобы убедиться в безопасности, литералы `key path` должны захватывать значение соотвествующее протоколу `Sendable`.
Это затрагивает использование сабскриптов в `key paths`:

```swift
class SomeClass: Hashable {
  var value: Int
}

class SomeContainer {
  var dict: [SomeClass : String]
}

let sc = SomeClass(...)

// ошибка: при захвате 'sc' в key path необходимо подписать 'SomeClass'
// на 'Sendable'
let keyPath = \SomeContainer.dict[sc]
```
